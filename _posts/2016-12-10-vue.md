---
layout: default
title: vue 使用
description: ''
show_header: true
---

使用Vue的原因是它比较简单，不谈性能方面。
之前使用过Backbone,它对于数据更新之后的视图更新需要自己手动操作，这点比较麻烦，
而Vue已经把数据和视图的更新进行绑定，可以减少代码量，只专注于底层逻辑。


下面只是对自己在使用过程中一些要注意的地方进行记录，主要是Vue2.0。

Vue实例的生命周期
```created => mounted => updated => destroyed```

对于文本的展示尽量使用```v-text```，因为使用```{{variable}}```形式，在DOM还没渲染完会出现{{}}，除非加上```v-cloak```。
还可以使用```v-html```进行html内容的渲染，尽量少用。

filters只能被用于```{{}}```和```v-bind```中，不能被用在```v-text```

2.0的数据流都是单向的，取消了1.0中的sync数据绑定形式，不过用于表单的```v-model```还是双向的。不过只是语法糖，
```
<input v-bind:value="something" v-on:input="something = $event.target.value">
```
只有在Vue实例中的```data```属性里的变量才是reactive。

组件的形式可以更好的帮助我们对于做页面的组织规划和清晰的数据流。
有一些html标签对于元素内容的填充有限制，需要使用```is```进行组件标记, 如```ul中的li, ol中的li, table中的tr, select中的option```
传入组件的变量需要蛇形变量的写法，
如testVariable，传入组件时要变成```<component-example :test-variable="testVariable，传入组件时要变成"></component-example>```

简写
```v-bind:href` => :href```
```v-on:click => @click ```


对于computed属性比直接通过方法计算出来的值要好，也比通过watch的方式要好，
因为computed属性是有缓存的，只有原属性发生改变了，它才改变。
不过当一些操作比较费时或耗费较大时，应该使用watch,延迟一下响应。


类和样式的绑定有两种方式。
对象语法
```
v-bind:class="{activeClass: isActive}"
v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"
```

数组语法
```
v-bind:class="[isActive ? activeClass : '']"
v-bind:style="[baseStyles, overridingStyles]"，baseStyles, overridingStyles是对象
```

循环遍历数组
```
v-for="(item, index) in items" or v-for="item of items"
```
循环遍历对象
```
v-for="(value, key) in object" v-for="(value, key, index) in object"
```
对于可以重复使用的组件,如果需要重新生成，要用```:key```进行标记


父子组件的属性传递，通过```props down, events up```, 确保单一的数据流，使逻辑清晰。
子组件通过```$on(监听事件), $emit(触发事件)```修改父组件中的数据，如
```
<component-example v-on:increment="incrementTotal">
    <button v-on:click="increment1">{{ counter }}</button>
</component-example>
increment1: function() {
    this.$emit('increment');
}
```
其中incrementTotal是父组件中的方法，v-on中的increment是对应的监听事件名称，组件内的increment1是组件的方法。
也可以用于兄弟组件。