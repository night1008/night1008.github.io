---
layout: post
keywords: go,code,gist
description: Go的代码片段
title: Go的代码片段
comments: true
---

定时任务中，为了获得下一次任务执行时间，服务器所在时区的下一天

```go
func nextDay(now time.Time) time.Time {
    _, offset := now.Zone()
    offsetHour := time.Duration(offset) * time.Second
    return now.
        Add(offsetHour).
        Add(24 * time.Hour).
        Truncate(24 * time.Hour).
        Add(-offsetHour)
}

// 或者

func nextDay(now time.Time) time.Time {
    next := now.Add(24 * time.Hour)
    return time.Date(next.Year(), next.Month(), next.Day(), 0, 0, 0, 0, next.Location())
}
```

复制数组

```go
a1 := []int{1, 2, 3, 4, 5}
a2 := []int{6, 7, 8, 9, 10}
r := make([]int, len(a1)+len(a2))
copy(r, a1)
copy(r[len(a1):], a2)
a1[0] = 11  // 这时候修改 a1 不会影响到 r
fmt.Println(r)
```

mac环境下编译成linux执行程序

```
GOOS=linux GOARCH=amd64 go build main.go

GOOS=linux GOARCH=amd64 go build -o main
```

chan 理解

无缓冲通道和有缓冲且缓冲已满的通道，发送消息时，如果没被接收，会阻塞线程(移交线程控制权)，
同理无缓冲通道和有缓冲且没有消息的通道，接收消息时，如果没有消息，也会阻塞线程(移交线程控制权)

### context

context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。
context 是用来解决 goroutine 之间退出通知、元数据传递的功能。
background 通常用在 main 函数中，作为所有 context 的根节点。
todo 通常用在并不知道传递什么 context的情形。

注意事项：
1. 不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。
2. 不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。
3. 不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。
4. 同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。