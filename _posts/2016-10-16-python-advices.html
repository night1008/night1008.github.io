---
layout: default
title: Python 建议
description: ''
---

<div class="blog-header">
	<h1 class="blog-title">{{ page.title }}</h1>
	<p class="lead blog-description">
		记录一些关于Python的一些建议。
	</p>
</div>

<div class="row">
	<div class="col-md-12">
		<p>
			python的pickle只能用于Python语言
			解析xml最好用lxml
		</p>
		<p>
		单例实现思路: 利用Python的<b>模块机制</b>，
		如果使用类的实现思路，还有考虑锁和重载问题。
		<blockquote>
			<ol>
				<li>所有的变量都会绑定到模块上</li>
				<li>模块只初始化一次</li>
				<li>import机制是线程安全的(在并发状态下模块也只有一个实例)</li>
			</ol>
		</blockquote>
		<code>
			import module;
			module.run()
		</code>
		</p> 

		<p>
			mixni模式：
			类的__bases__(是个元组)属性可以动态地指定基类。
		</p>

		<p>
			发布订阅模式实现松耦合<br>
			日志系统<br>
			python的message库
		</p>

		<p>
			状态模式<br>
			可以避免使用过多的装饰器和判断代码
			python的state库
		</p>

		<p>
			判断一个类是古典类还是新式类应该从其 __metaclass__ 上看，而不是从定义上看。
			<blockquote>
				class A:
					pass
				class B(object):
					pass
			</blockquote>

		</p>

		<p>
			__init__()不是类的构造方法。<br>
			构造方法： __new__()，<br>
			__init__()只是进行初始化，两者参数应该保持一致。<br>
			__new__() 一般返回类的对象，若没有返回，则__init__()不会执行<br>
			当子类继承自不可变子类事，需要覆盖__new__()<br>
			__new__() 可以用来实现工程模式<br>
			子类的__int__()不显示调用父类的__init__()时，父类的__init__()方法不会被调用<br>
		</p>

		<p>
			<h5>名字查找机制(LEGB)</h5>
			局部作用域 -> 嵌套作用域 -> 全局作用域(仅限单个文件) -> 内置作用域(__builtin__)
		</p>

		<p>
			<h5>MRO(方法解析顺序, 适用于数据属性)</h5>
			古典类中采用的是自左向右的深度优先算法，<br>
			新式类中可在__mro__中查看
		</p>
		<h3> PEP8 </h3>

		<h3> 缩进 </h3>
		<p> 使用4个空格作为缩进 </p>

		<h3> 异常类名 </h3>

		<p> 应该有后缀** ERROR ** </p>

		<h3> 方法名称 </h3>

		<p> 小写且用下划线分隔 </p>

		<h3> 方法参数 </h3>

		<p>
		    <b> self </b>作为实例方法的第一个参数，<b> cls</b>作为类方法的第一个参数。
		    一些参数为关键字名称的，最好是关键字加上一个下划线后缀，比如，class_ 比 clss好。
		<p>

		<h3> 方法名称和实例名称 </h3>

		<p>
		    前置的单个下划线表示非公共的方法名称和实例名称
		    前置的两个下划线表示不可被外部调用
		<p>

		<h3> 常量 </h3>

		<p> 字母大写且用下划线分隔 </p>

		<h3> 编程建议 </h3>

		<p> 
		    使用 <b> is </b> 判断是否为 None，而不是用=。
		    使用 is not ... 而不要使用 not is ...
		<p>
	</div>
</div>