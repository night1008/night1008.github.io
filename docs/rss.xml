<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Night1008</title><link>https://night1008.github.io</link><description>静以修身，俭以养德</description><copyright>Night1008</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://night1008.github.io</link></image><lastBuildDate>Wed, 26 Nov 2025 10:14:12 +0000</lastBuildDate><managingEditor>Night1008</managingEditor><ttl>60</ttl><webMaster>Night1008</webMaster><item><title>Go 多类型 case 的公共类型是 interface{}</title><link>https://night1008.github.io/post/Go%20-duo-lei-xing-%20case%20-de-gong-gong-lei-xing-shi-%20interface%7B%7D.html</link><description>写了一个去除 `map` 中的零数值的方法，如下所示，  
发现当有些值为 `int64` 类型时，即使为零数值也不会去除，

```go
func RemoveMapZeroNumValue(m map[string]interface{}, excludeKeysMap map[string]struct{}) map[string]interface{} {
	for k, v := range m {
		if _, ok := excludeKeysMap[k]; ok {
			continue
		}
		switch val := v.(type) {
		case int, int8, int16, int32, int64,
			uint, uint8, uint16, uint32, uint64,
			float32, float64:
			if val == 0 || val == 0.0 {
				delete(m, k)
			}
		}
	}
	return m
}
```

原来Go 的多类型 case 不会把 val 的类型统一，它只保证你进入了这个 case，
Go 的 type switch 规则：
- val 的静态类型为所有 case 的「公共类型」
- 多个类型的公共类型就是 interface{}
- 所以 val 的静态类型是 interface{}

写法 | val 的实际类型 | 比较结果
-- | -- | --
case int: | int | val == 0 正常
case int, float64: | interface{} | val == 0 永远 false

解决方法：
1. 使用 `reflect.ValueOf(val).IsZero()` 判断
2. 拆分所有 case 。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-duo-lei-xing-%20case%20-de-gong-gong-lei-xing-shi-%20interface%7B%7D.html</guid><pubDate>Mon, 24 Nov 2025 10:06:52 +0000</pubDate></item><item><title>Gorm clickhouse CreateInBatches 执行报错</title><link>https://night1008.github.io/post/Gorm%20clickhouse%20CreateInBatches%20-zhi-xing-bao-cuo.html</link><description>通过 [gorm clickhouse](https://github.com/go-gorm/clickhouse) 进行批量数据插入时，如果超过批大小，就会报以下错误，

```
[clickhouse][conn=1][127.0.0.1:9000][exception] code: 101, message: Unexpected packet Query received from client
[clickhouse-std][conn=0][127.0.0.1:9000] PrepareContext error: code: 101, message: Unexpected packet Query received from client
```

测试代码如下，

```go
package main

import (
	'crypto/md5'
	'fmt'
	'io'
	'time'

	std_ck 'github.com/ClickHouse/clickhouse-go/v2'
	'gorm.io/datatypes'
	'gorm.io/driver/clickhouse'
	'gorm.io/gorm'
)

type AdTencentReportCK struct {
	AppID      int64  `json:'app_id'`                            // funnydb 应用ID
	ReportID   string `json:'report_id'`                         // 报表ID
	ReportType string `json:'report_type'`                       // 报表类型
	Level      string `json:'level'`                             // 报表类型级别
	TimeLine   string `json:'time_line'`                         // 时间口径
	AccountId  int64  `json:'account_id'`                        // 账号ID
	Date       string `json:'date'`                              // 日期
	Hour       int64  `json:'hour'`                              // 小时(0-23)
	IngestTime int64  `json:'ingest_time' gorm:'autoCreateTime'` // 采集时间，毫秒级
	Data       datatypes.JSON
}

func (AdTencentReportCK) TableName() string {
	return 'ad_tencent_reports_test'
}

func GenerateReportID(keys ...string) string {
	w := md5.New()
	for _, key := range keys {
		_, _ = io.WriteString(w, key)
	}
	return fmt.Sprintf('%x', w.Sum(nil))
}

func main() {
	ckSTDDB := std_ck.OpenDB(&amp;std_ck.Options{
		Addr: []string{'127.0.0.1:9000'},
		Auth: std_ck.Auth{
			Database: 'ad_reports',
			Username: 'admin',
			Password: 'secret',
		},
		Settings: std_ck.Settings{
			'max_execution_time': 3600,
			'final':              1,
		},
		DialTimeout: 5 * time.Second,
		Compression: &amp;std_ck.Compression{
			Method: std_ck.CompressionLZ4,
		},
		Debug: true,
	})

	ckDB, err := gorm.Open(clickhouse.New(clickhouse.Config{
		Conn: ckSTDDB,
	}))
	if err != nil {
		panic(err)
	}

	var reports []*AdTencentReportCK
	for i := 0; i &lt; 110; i++ {
		report := AdTencentReportCK{
			AppID:      1,
			ReportID:   GenerateReportID('1', fmt.Sprintf('%d', i+1)),
			ReportType: 'daily_reports',
			Level:      'REPORT_LEVEL_ADVERTISER',
			TimeLine:   'ACTIVE_TIME',
			AccountId:  int64(i + 1),
			Date:       '2025-01-01',
			IngestTime: 1763308800,
			Data:       datatypes.JSON(`{'cost': 1000}`),
		}
		reports = append(reports, &amp;report)
	}

	if err := ckDB.CreateInBatches(reports, 100).Error; err != nil {
		panic(err)
	}
}
```

解决方式，直接使用，
```go
if err := ckDB.Create(reports).Error; err != nil {
	panic(err)
}
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Gorm%20clickhouse%20CreateInBatches%20-zhi-xing-bao-cuo.html</guid><pubDate>Thu, 20 Nov 2025 06:11:44 +0000</pubDate></item><item><title>服务端菜单权限组如何设计</title><link>https://night1008.github.io/post/fu-wu-duan-cai-dan-quan-xian-zu-ru-he-she-ji.html</link><description>### 背景
目前系统的权限体系存储了权限，权限组，角色之间的关联关系，如下图所示，

&lt;img width='1213' height='438' alt='Image' src='https://github.com/user-attachments/assets/e12754df-d6ab-4b31-bf8c-53599d60b5e0' /&gt;

目前的数据结构如下，
```go
type PermissionGroup struct {
  ID       uint64 `gorm:'primarykey'`           // 数据库ID
  AppID    uint64 `gorm:'uniqueIndex:idx_permission_groups_name'`
  Name     string `gorm:'not null;uniqueIndex:idx_permission_groups_name' yaml:'name'`
  Title    string `yaml:'title'`
  ParentID uint64 // 父权限ID

  PermissionGroupPermission []*PermissionGroupPermission `gorm:'foreignKey:GroupName;references:Name'`
}

type PermissionGroupPermission struct {
  ID            uint64 `gorm:'primarykey'`           // 数据库ID
  AppID         uint64 `gorm:'uniqueIndex:idx_group_permissions'`
  GroupName     string `gorm:'uniqueIndex:idx_group_permissions'`
  PermissionKey string `gorm:'uniqueIndex:idx_group_permissions'`

  PermissionGroup *PermissionGroup `gorm:'foreignkey:Name;references:GroupName'`
  Permission      *Permission      `gorm:'foreignkey:UniqueKey;references:PermissionKey'`
}

type Permission struct {
  ID        uint64 `gorm:'primarykey'`           // 数据库ID
  Name      string `gorm:'not null;uniqueIndex:idx_permissions_name' yaml:'name'`
  Action    string `gorm:'uniqueIndex:idx_permissions_name' yaml:'action'`
  UniqueKey string `gorm:'uniqueIndex:idx_unique_key' yaml:'unique_key'`
  Title     string `yaml:'title'`
}
```
其实存在了一些问题，
1. 没有必要存储 permissions, permission_group_permissions, permission_groups
2. 无法调整菜单顺序
3. 无法指定菜单依赖

---

### 方案
1. 减少对于 permissions, permission_group_permissions, permission_groups 的数据存储
2. 整份权限元数据以配置的方式进行加载
3. 权限组增加依赖字段

如下图所示，

&lt;img width='693' height='453' alt='Image' src='https://github.com/user-attachments/assets/8fff5852-8faa-4317-920d-5b3f3172ffe6' /&gt;

 效果如下，
1. 直接返回给前端树形结构，方便使用
2. 权限组 key 自行保证唯一
3. 服务端只需要保存权限组 key
4. 权限组层级可以统一配置公共路由
5. 通过读取权限组配置可以随时调整顺序
6. 可以指定权限组依赖关系

数据结构如下，

```go
type PermissionGroup struct {
	Name        string             `yaml:'name'`
	Title       string             `yaml:'title'`
	Needs       []string           `yaml:'needs'`
	Groups      []*PermissionGroup `yaml:'groups'`
	Permissions []struct {
		Method string `yaml:'method'`
		Path   string `yaml:'path'`
	} `yaml:'permissions'`
}
```

```yaml
- name: 'operation-report'
  title: '运营报表'
  groups:
    - name: 'overview-data'
      title: '概览数据'
      groups:
        - name: 'overview-day'
          title: '查看日概览'
          permissions:
            - method: GET
              path: overview-new
        - name: 'edit-overview'
          title: '编辑概览看板'
          needs:
            - overview-day
          permissions:
            - method: PUT
              path: edit-overview
```。</description><guid isPermaLink="true">https://night1008.github.io/post/fu-wu-duan-cai-dan-quan-xian-zu-ru-he-she-ji.html</guid><pubDate>Thu, 30 Oct 2025 05:57:05 +0000</pubDate></item><item><title>Mac 使用小技巧</title><link>https://night1008.github.io/post/Mac%20-shi-yong-xiao-ji-qiao.html</link><description>### caffeinate
```sh
caffeinate -d # 防止显示器关闭
caffeinate -i  # 保持系统不休眠
caffeinate -t 1800  # 保持 30 分钟
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Mac%20-shi-yong-xiao-ji-qiao.html</guid><pubDate>Mon, 15 Sep 2025 14:26:28 +0000</pubDate></item><item><title>开发工具汇总</title><link>https://night1008.github.io/post/kai-fa-gong-ju-hui-zong.html</link><description>### Go 导入自动补全
&gt; vscode, cursor 等编辑器上

```sh
go install -v golang.org/x/tools/gopls@latest

go install -v golang.org/x/tools/cmd/goimports@latest
```

---

### Postgres IDE
[postico2](https://releases.eggerapps.at/postico2/downloads)。</description><guid isPermaLink="true">https://night1008.github.io/post/kai-fa-gong-ju-hui-zong.html</guid><pubDate>Sun, 31 Aug 2025 11:17:18 +0000</pubDate></item><item><title>如何基于定时规则生成任务</title><link>https://night1008.github.io/post/ru-he-ji-yu-ding-shi-gui-ze-sheng-cheng-ren-wu.html</link><description>### 数据结构
```go
// 规则
type ScheduleRule struct {
  ID             int64         // 规则ID
  Title          string        // 规则标题
  Payload        string        // 规则内容
  Enabled        bool          // 规则开关
  StartTime      time.Time     // 开始时间
  EndTime        time.Time     // 结束时间
  NextCheckTime  sql.NullTime  // 下次检查时间
  CheckFrequency string        // 检查频率
}

// 任务
type RuleTask struct {
  ID             int64         // 任务ID
  RuleID         int64         // 规则ID
  RunTime        time.Time     // 开始时间
  Payload        string        // 规则内容
  Status         string        // 任务状态
  Result         string        // 任务结果
}
```

### 注意事项
1. 改开始时间，不能早于当前时间，重新计算 next_check_time
2. 改结束时间，不能早于当前时间，直接修改
3. 改检查频率，重新计算 next_check_time
4. 改规则开关，如果开启，重新计算 next_check_time
5. next_check_time 为距离当前时间最近的下一次执行时间
6. 生成任务和编辑规则时均需要锁定规则，防止并发。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-ji-yu-ding-shi-gui-ze-sheng-cheng-ren-wu.html</guid><pubDate>Thu, 28 Aug 2025 06:45:56 +0000</pubDate></item><item><title>使用阿里云函数计算实现异步任务</title><link>https://night1008.github.io/post/shi-yong-a-li-yun-han-shu-ji-suan-shi-xian-yi-bu-ren-wu.html</link><description>最近在业务上希望独立出一个任务服务，且在服务重启过程中，不中断任务执行，
看了一下，感觉阿里云函数挺符合场景的，有如下优势，

1. 通过 HTTP 触发器触发任务
2. 任务有异步队列机制
3. 可以指定函数配额
4. 错误有重试机制
5. 未执行的任务会使用最新代码执行

### 任务流程
&lt;img width='300' height='300' alt='Image' src='https://github.com/user-attachments/assets/ffd36e46-77d6-4420-95a0-6372391bb343' /&gt;

1. 通过定时轮询规则表
2. 创建任务到数据库
3. 发送任务到阿里云函数，记录请求ID到任务中

### 注意点
测试中发现，异步任务并没有完全先进先出，
除非使用阿里云的消息队列服务，
不然需要控制任务发送不要超过函数配额

测试代码如下

```go
package main

import (
	'bytes'
	'encoding/json'
	'fmt'
	'net/http'
	'sync'
	'time'
)

func main() {
	url := 'https://fc-test-vbhrdreedw.cn-shanghai.fcapp.run'
	now := time.Now()
	client := http.Client{}

	var wg sync.WaitGroup
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()

			data := map[string]interface{}{
				'name': 'foo',
				'age':  i,
			}
			jsonData, err := json.Marshal(data)
			if err != nil {
				return
			}

			req, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer(jsonData))
			if err != nil {
				fmt.Println('===&gt; req ', err)
				return
			}
			req.Header.Add('X-Fc-Invocation-Type', 'Async')    // 异步调用
			req.Header.Add('Content-Type', 'application/json') // 保证参数解析

			token := 'token-abc'
			req.Header.Add('Authorization', 'Bearer '+token) // Bearer 认证

			resp, err := client.Do(req)
			if err != nil {
				fmt.Println('===&gt; resp ', err)
				return
			}
			requestId := resp.Header.Get('X-Fc-Request-Id')
			fmt.Println('===&gt; requestId ', requestId)
		}(i)
	}
	wg.Wait()
	fmt.Println('===&gt; time ', time.Since(now))
}
```。</description><guid isPermaLink="true">https://night1008.github.io/post/shi-yong-a-li-yun-han-shu-ji-suan-shi-xian-yi-bu-ren-wu.html</guid><pubDate>Wed, 13 Aug 2025 03:29:52 +0000</pubDate></item><item><title>如何使用 Cloudflare Tunnels 提供内网 http 服务</title><link>https://night1008.github.io/post/ru-he-shi-yong-%20Cloudflare%20Tunnels%20-ti-gong-nei-wang-%20http%20-fu-wu.html</link><description>最近在推特上看到可以使用 Cloudflare Tunnels 提供内网服务，于是尝试了一下，在此作下记录。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-shi-yong-%20Cloudflare%20Tunnels%20-ti-gong-nei-wang-%20http%20-fu-wu.html</guid><pubDate>Sun, 10 Aug 2025 06:49:58 +0000</pubDate></item><item><title>游戏账号如何匹配多次广告渠道归因下的充值数据</title><link>https://night1008.github.io/post/you-xi-zhang-hao-ru-he-pi-pei-duo-ci-guang-gao-qu-dao-gui-yin-xia-de-chong-zhi-shu-ju.html</link><description>我们可以记录每次广告账号的归因情况，尤其是归因时间和归因渠道。</description><guid isPermaLink="true">https://night1008.github.io/post/you-xi-zhang-hao-ru-he-pi-pei-duo-ci-guang-gao-qu-dao-gui-yin-xia-de-chong-zhi-shu-ju.html</guid><pubDate>Wed, 06 Aug 2025 10:48:48 +0000</pubDate></item><item><title>管理二三事</title><link>https://night1008.github.io/post/guan-li-er-san-shi.html</link><description>最近由于组织架构调整，有几个人归属到我下面，
本人不喜欢开会，但感觉有些会还是要开的，
因此记录下本人认为某些会的开会内容。</description><guid isPermaLink="true">https://night1008.github.io/post/guan-li-er-san-shi.html</guid><pubDate>Tue, 22 Jul 2025 09:20:58 +0000</pubDate></item><item><title>Gorm PostgreSQL Generated Columns 结构体定义第二次执行报错</title><link>https://night1008.github.io/post/Gorm%20PostgreSQL%20Generated%20Columns%20-jie-gou-ti-ding-yi-di-er-ci-zhi-xing-bao-cuo.html</link><description>业务上想通过 PostgreSQL Generated Columns 自动把 JSON 字段生成为新的列，如下所示，

```go
type AdPlatformEventTrackReport struct {    
    // Your regular fields
    Data datatypes.JSON `gorm:'type:jsonb;column:data'`  // Explicit column name
    
    // Generated column with explicit column name
    TrackPayAmount float64 `gorm:'&lt;-:false;column:track_pay_amount;type:float GENERATED ALWAYS AS ((data-&gt;&gt;'track_pay_amount')::float) STORED'`
}
```

第一次执行迁移是可以正常创建列的，但是第二次执行就会报如下错误，

```sh
ERROR: syntax error at or near 'GENERATED' (SQLSTATE 42601)
[0.821ms] [rows:0] ALTER TABLE 'ad_platform_event_track_reports' ALTER COLUMN 'track_pay_amount' TYPE float GENERATED ALWAYS AS ((data-&gt;&gt;'track_pay_amount')::float) STORED USING 'track_pay_amount'::float GENERATED ALWAYS AS ((data-&gt;&gt;'track_pay_amount')::float) STORED
```

尝试了几次仍然无法解决，最后只能先用以下方式解决。</description><guid isPermaLink="true">https://night1008.github.io/post/Gorm%20PostgreSQL%20Generated%20Columns%20-jie-gou-ti-ding-yi-di-er-ci-zhi-xing-bao-cuo.html</guid><pubDate>Tue, 22 Jul 2025 09:14:20 +0000</pubDate></item><item><title>Git 使用记录</title><link>https://night1008.github.io/post/Git%20-shi-yong-ji-lu.html</link><description>### 回滚提交

```sh
git reset HEAD~

git push origin branchName -f
```
---

### 使用 git-token 下载仓库
```
git clone https://&lt;user-name&gt;:&lt;git-token&gt;@&lt;github-path.git&gt;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Git%20-shi-yong-ji-lu.html</guid><pubDate>Sat, 19 Jul 2025 09:49:35 +0000</pubDate></item><item><title>MySQL 业务使用手册</title><link>https://night1008.github.io/post/MySQL%20-ye-wu-shi-yong-shou-ce.html</link><description>### 查询数据库大小
```sql
SELECT
  table_schema,
  ROUND(SUM(data_length) / 1024 / 1024 / 1024, 2) AS data_size,
  ROUND(SUM(index_length) / 1024 / 1024 / 1024, 2) AS index_size
FROM
  information_schema.TABLES
GROUP BY
  table_schema
ORDER BY
  2 DESC;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/MySQL%20-ye-wu-shi-yong-shou-ce.html</guid><pubDate>Thu, 10 Jul 2025 02:14:33 +0000</pubDate></item><item><title>Go Gorm 使用记录</title><link>https://night1008.github.io/post/Go%20Gorm%20-shi-yong-ji-lu.html</link><description>### 先 union 再聚合

```go
var results []struct {
    Category string
    SumTotal int
}

err := db.Table('(?) as t', 
    db.Model(&amp;Table1{}).Select('category, COUNT(*) as total').Group('category').
    Union(db.Model(&amp;Table2{}).Select('category, COUNT(*) as total').Group('category')),
).
Select('category, SUM(total) as sum_total').
Group('category').
Find(&amp;results).Error

if err != nil {
    // 处理错误
}
```

---

### 复制 db  查询
```go
db, _ := gorm.Open(sqlite.Open('test.db'), &amp;gorm.Config{})
    
// Original query
original := db.Where('name = ?', 'Alice')
    
// Create independent copy
copy := original.Session(&amp;gorm.Session{})
    
// Modify the copy without affecting original
copy = copy.Where('age &gt; ?', 20)
    
// Original still only has the name condition
// Copy has both name and age conditions
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20Gorm%20-shi-yong-ji-lu.html</guid><pubDate>Thu, 03 Jul 2025 09:46:19 +0000</pubDate></item><item><title>Golang 如何加快镜像打包速度</title><link>https://night1008.github.io/post/Golang%20-ru-he-jia-kuai-jing-xiang-da-bao-su-du.html</link><description>原来镜像打包过程中可以指定挂载缓存和编译结果路径

```sh
FROM golang:1.23.9-alpine3.21 AS builder

WORKDIR /app

COPY . /app/

ARG BUILD_VERSION

ENV BUILD_VERSION=${BUILD_VERSION:-develop} \
    GOPROXY=https://goproxy.cn,direct

RUN --mount=type=cache,target=/root/.cache/go-build \
    --mount=type=cache,target=/go \
    go mod download \
    &amp;&amp; go build -o demo-web --ldflags='-X 'main.buildVersion=$BUILD_VERSION'' .

FROM alpine:3.20

# 解决 Go 时区加载 unknown time zone XXX 的问题
RUN apk update &amp;&amp; apk add tzdata

COPY --from=builder /app/demo-web /usr/bin/demo-web
```

参考链接
- [Optimize cache usage in builds](https://docs.docker.com/build/cache/optimize/)
- [BuildKit](https://yeasy.gitbook.io/docker_practice/buildx/buildkit)。</description><guid isPermaLink="true">https://night1008.github.io/post/Golang%20-ru-he-jia-kuai-jing-xiang-da-bao-su-du.html</guid><pubDate>Tue, 01 Jul 2025 07:23:35 +0000</pubDate></item><item><title>Go 单个仓库如何提供多个指定版本的 sdk 包</title><link>https://night1008.github.io/post/Go%20-dan-ge-cang-ku-ru-he-ti-gong-duo-ge-zhi-ding-ban-ben-de-%20sdk%20-bao.html</link><description>业务上需要对外提供一些 sdk 包方便相关人员使用，
会把一些常量定义到 `api` 包中，供 `client` 引用，如下所示，

```
go-sdk-test
  - api
     api.go
     go.mod
  - client
     client.go
     go.mod
```

在 `client` 使用时，直接下载的包版本是 `v0.0.0-20250628093558-4e219645ad46` 这种格式的，
```sh
go get github.com/night1008/go-sdk-test/api
```
&gt; go: downloading github.com/night1008/go-sdk-test/api v0.0.0-20250628093558-4e219645ad46
&gt; go: added github.com/night1008/go-sdk-test/api v0.0.0-20250628093558-4e219645ad46


即使给仓库打上 `v0.1.0` 仍然无法指定到具体版本，如下所示
```sh
go get github.com/night1008/go-sdk-test/api@v0.1.0
```
&gt; go: module github.com/night1008/go-sdk-test@v0.1.0 found, but does not contain package github.com/night1008/go-sdk-test/api

原来打标签的时候还要多指定下子包路径才可以正常下载
```sh
git tag api/v0.1.0
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-dan-ge-cang-ku-ru-he-ti-gong-duo-ge-zhi-ding-ban-ben-de-%20sdk%20-bao.html</guid><pubDate>Sat, 28 Jun 2025 10:10:04 +0000</pubDate></item><item><title>golang 如何独立 gin swagger 启动命令</title><link>https://night1008.github.io/post/golang%20-ru-he-du-li-%20gin%20swagger%20-qi-dong-ming-ling.html</link><description>之前的业务代码中需要生成 gin swagger 用于和前端联调，且和主流程代码放在一起，
导致打包镜像的时候也需要先生成 swagger，目前看这个只是用于本地和前端联调，
因此独立 gin swagger 启动命令。</description><guid isPermaLink="true">https://night1008.github.io/post/golang%20-ru-he-du-li-%20gin%20swagger%20-qi-dong-ming-ling.html</guid><pubDate>Thu, 19 Jun 2025 02:30:49 +0000</pubDate></item><item><title>markdown 用法记录</title><link>https://night1008.github.io/post/markdown%20-yong-fa-ji-lu.html</link><description>### 删除线

```
~~这段文本会被划掉~~
```

~~这段文本会被划掉~~。</description><guid isPermaLink="true">https://night1008.github.io/post/markdown%20-yong-fa-ji-lu.html</guid><pubDate>Wed, 18 Jun 2025 03:15:53 +0000</pubDate></item><item><title>golang wire 如何注入两个相同类型的变量</title><link>https://night1008.github.io/post/golang%20wire%20-ru-he-zhu-ru-liang-ge-xiang-tong-lei-xing-de-bian-liang.html</link><description>如果使用 wire 初始化两个相同类型的变量，会报以下错误，

&gt; BaseProviderSet has multiple bindings for *gorm.io/gorm.DB

---

解决方式，先对变量定义新类型，最后使用的时候再转换成原来的类型。</description><guid isPermaLink="true">https://night1008.github.io/post/golang%20wire%20-ru-he-zhu-ru-liang-ge-xiang-tong-lei-xing-de-bian-liang.html</guid><pubDate>Thu, 12 Jun 2025 02:12:48 +0000</pubDate></item><item><title>github 如何评论变更代码</title><link>https://night1008.github.io/post/github%20-ru-he-ping-lun-bian-geng-dai-ma.html</link><description>手动插入代码块
使用Markdown语法在评论中插入代码块：

```diff
// 显示差异的代码示例
- old_code();  // 被删除的行
+ new_code();  // 新增的行
```。</description><guid isPermaLink="true">https://night1008.github.io/post/github%20-ru-he-ping-lun-bian-geng-dai-ma.html</guid><pubDate>Thu, 05 Jun 2025 01:38:09 +0000</pubDate></item><item><title>阿里云函数计算 Go 语言下不同调用方式传入参数的反序列化问题</title><link>https://night1008.github.io/post/a-li-yun-han-shu-ji-suan-%20Go%20-yu-yan-xia-bu-tong-diao-yong-fang-shi-chuan-ru-can-shu-de-fan-xu-lie-hua-wen-ti.html</link><description>最近尝试使用阿里云函数计算，发现使用`定时器触发器`的方式传入的参数内容无法正确反序列化，如下所示，

```go
func HandleRequest(ctx context.Context, event SomeStruct) error {
	log.Println('===&gt; param: ', event)
}
```

后面把 event 为指定为 `map[string]interface{}`，打印后发现，不同调用方式的传入参数内容不同，如下所示，

```go
func HandleRequest(ctx context.Context, event map[string]interface{}) error {
	log.Println('===&gt; param: ', event)
}
```

### 定时器触发器
```
map[payload:{'debug':true,'app_id':74,'account_ids':[1823998827268096,1823998807388364,1823998819034986,1823998841668699,1823998805359619,1823998842198409]} triggerName:funnyads_ad_material_monitor triggerTime:2025-04-24T09:46:00Z]
```

### 网页测试接口
```
map[account_ids:[1823998827268096,1823998807388364,1823998819034986,1823998841668699,1823998805359619,1823998842198409] app_id:74 debug:true]
```

可以用以下方式做兼容处理

```go
func HandleRequest(ctx context.Context, event map[string]interface{}) error {
  var param SomeStruct
	// 先简单判断是否来自定时触发器
	if _, ok := event['payload']; ok {
		if err := json.Unmarshal([]byte(event['payload'].(string)), &amp;param); err != nil {
			return err
		}
	} else {
		eventData, err := json.Marshal(event)
		if err != nil {
			return err
		}
		if err := json.Unmarshal(eventData, &amp;param); err != nil {
			return err
		}
	}
  ...
}
```
。</description><guid isPermaLink="true">https://night1008.github.io/post/a-li-yun-han-shu-ji-suan-%20Go%20-yu-yan-xia-bu-tong-diao-yong-fang-shi-chuan-ru-can-shu-de-fan-xu-lie-hua-wen-ti.html</guid><pubDate>Thu, 24 Apr 2025 10:06:42 +0000</pubDate></item><item><title>阿里云 SLS 使用记录</title><link>https://night1008.github.io/post/a-li-yun-%20SLS%20-shi-yong-ji-lu.html</link><description>### 正则匹配某个容器下的日志

```sql
_container_name_ = pod-name and content:#'foo'
```

---。</description><guid isPermaLink="true">https://night1008.github.io/post/a-li-yun-%20SLS%20-shi-yong-ji-lu.html</guid><pubDate>Thu, 10 Apr 2025 03:13:25 +0000</pubDate></item><item><title>Golang gorm 实现任意层级的文件夹模型</title><link>https://night1008.github.io/post/Golang%20gorm%20-shi-xian-ren-yi-ceng-ji-de-wen-jian-jia-mo-xing.html</link><description>记录一下如何使用 gorm 实现任意层级的文件夹模型，代码如下


```go
type AdFolder struct {
	ID        uint64 `gorm:'primarykey'`           // 数据库ID
	CreatedAt int64  `gorm:'autoCreateTime:milli'` // 记录创建时间，单位 milli
	UpdatedAt int64  `gorm:'autoUpdateTime:milli'` // 记录更新时间，单位 milli

	AppID       uint64 `gorm:'index:idx_ad_folders_type'` // 应用ID
	Type        string `gorm:'index:idx_ad_folders_type'` // 分类类型
	Title       string // 标题
	Description string // 说明
	ParentID    uint64 `gorm:'index'` // 父文件夹ID
	RootID      uint64 `gorm:'index'` // 根文件夹ID

	CreatorID    uint64 // 创建用户ID
	LastEditorID uint64 // 最后编辑用户ID

	Parent      *AdFolder   `gorm:'foreignKey:ParentID'` // 父节点
	Children    []*AdFolder `gorm:'foreignKey:ParentID'` // 直系子节点
	Root        *AdFolder   `gorm:'foreignKey:RootID'`   // 根节点
	Descendants []*AdFolder `gorm:'foreignKey:RootID'`   // 根系子节点
}


// 获取根文件夹ID
func (a *AdFolder) GetFolderRootID() uint64 {
	var rootID uint64
	if a.RootID != 0 {
		rootID = a.RootID
	} else if a.ID != 0 {
		rootID = a.ID
	}
	return rootID
}

// 获取相同根节点的文件夹列表
func (a *AdFolder) GetSameRootAdFolders(tx *gorm.DB) ([]*AdFolder, error) {
	var adFolders []*AdFolder
	query := tx.Model(&amp;AdFolder{}).
		Where('app_id = ?', a.AppID).
		Where('type = ?', a.Type)
	if a.RootID == 0 {
		query = query.Where('(id = ? OR root_id = ?)', a.ID, a.ID)
	} else {
		query = query.Where('(id = ? OR root_id = ?)', a.RootID, a.RootID)
	}
	if err := query.Order('id DESC').
		Find(&amp;adFolders).Error; err != nil {
		return nil, err
	}
	return adFolders, nil
}

// 构造文件夹父节点数组
func (a *AdFolder) GetAdFolderParents(tx *gorm.DB) ([]*AdFolder, error) {
	adFolders, err := a.GetSameRootAdFolders(tx)
	if err != nil {
		return nil, err
	}
	adFoldersMap := make(map[uint64]*AdFolder, len(adFolders))
	parentAdFoldersMap := make(map[uint64]uint64, len(adFolders)) // children : parent
	for _, folder := range adFolders {
		adFoldersMap[folder.ID] = folder
		if folder.ParentID != 0 {
			parentAdFoldersMap[folder.ID] = folder.ParentID
		}
	}

	var parents []*AdFolder
	currentID := a.ID
	for {
		parentID, exists := parentAdFoldersMap[currentID]
		if !exists {
			break
		}

		parent, ok := adFoldersMap[parentID]
		if !ok {
			break
		}

		parents = append([]*AdFolder{parent}, parents...)
		currentID = parentID
	}
	return parents, nil
}

// 构造文件夹树形结构
func BuildAdFolderTree(adFolders []*AdFolder) []*AdFolder {
	adFoldersMap := make(map[uint64]*AdFolder, len(adFolders))
	for _, adFolder := range adFolders {
		adFoldersMap[adFolder.ID] = adFolder
	}

	var roots []*AdFolder
	for _, adFolder := range adFolders {
		if adFolder.ParentID == 0 {
			roots = append(roots, adFolder)
		} else {
			if parent, ok := adFoldersMap[adFolder.ParentID]; ok {
				parent.Children = append(parent.Children, adFolder)
				adFoldersMap[adFolder.ParentID] = parent
			}
		}
	}
	return roots
}

// 寻找所有后代节点
func (a *AdFolder) GetAdFolderDescendants(tx *gorm.DB) ([]*AdFolder, error) {
	adFolders, err := a.GetSameRootAdFolders(tx)
	if err != nil {
		return nil, err
	}
	adFoldersMap := make(map[uint64]*AdFolder)
	childrenMap := make(map[uint64][]uint64)

	for _, adFolder := range adFolders {
		adFoldersMap[adFolder.ID] = adFolder
		if adFolder.ParentID != 0 {
			childrenMap[adFolder.ParentID] = append(childrenMap[adFolder.ParentID], adFolder.ID)
		}
	}

	var children []*AdFolder
	queue := []uint64{a.ID}
	for len(queue) &gt; 0 {
		currentID := queue[0]
		queue = queue[1:]
		for _, childID := range childrenMap[currentID] {
			if child, exists := adFoldersMap[childID]; exists {
				children = append(children, child)
				queue = append(queue, childID)
			}
		}
	}
	return children, nil
}
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Golang%20gorm%20-shi-xian-ren-yi-ceng-ji-de-wen-jian-jia-mo-xing.html</guid><pubDate>Tue, 08 Apr 2025 10:19:54 +0000</pubDate></item><item><title>Golang json.Marshal 序列化转义问题</title><link>https://night1008.github.io/post/Golang%20json.Marshal%20-xu-lie-hua-zhuan-yi-wen-ti.html</link><description>Golang 对包含链接地址的数据进行序列化后发现地址不能直接使用了，测试代码如下。</description><guid isPermaLink="true">https://night1008.github.io/post/Golang%20json.Marshal%20-xu-lie-hua-zhuan-yi-wen-ti.html</guid><pubDate>Thu, 20 Mar 2025 08:27:22 +0000</pubDate></item><item><title>Golang MySQL 通过 interface{} 解析查询结果的内容为 []byte</title><link>https://night1008.github.io/post/Golang%20MySQL%20-tong-guo-%20interface%7B%7D%20-jie-xi-cha-xun-jie-guo-de-nei-rong-wei-%20%5B%5Dbyte.html</link><description>发现 Golang MySQL 下，MySQL 驱动默认把 interface{} 类型解析为 []byte，导致字符串和数字以 Base64 编码形式返回。</description><guid isPermaLink="true">https://night1008.github.io/post/Golang%20MySQL%20-tong-guo-%20interface%7B%7D%20-jie-xi-cha-xun-jie-guo-de-nei-rong-wei-%20%5B%5Dbyte.html</guid><pubDate>Mon, 10 Mar 2025 09:20:24 +0000</pubDate></item><item><title>不同广告渠道报表类型级别的对应关系</title><link>https://night1008.github.io/post/bu-tong-guang-gao-qu-dao-bao-biao-lei-xing-ji-bie-de-dui-ying-guan-xi.html</link><description>不同广告渠道报表类型级别的对应关系

|    | 广告主帐号 | 广告计划 | 广告创意 |
| -------- | ------- | ------- | ------- |
| 腾讯广告  | 账号ID(account_id)  | 广告组ID(adgroup_id)   | 动态创意ID(dynamic_creative_id) | 
| 巨量广告 | 广告主ID(advertiser_id)  | 项目ID(cdp_project_id)   | 广告ID(cdp_promotion_id) |


参考链接
- [腾讯广告 - 获取日报表](https://developers.e.qq.com/v3.0/docs/api/daily_reports/get)
- [巨量广告 - 获取自定义报表可用指标和维度](https://open.oceanengine.com/labels/7/docs/1755261744248832)
- [巨量广告 - 自定义报表](https://open.oceanengine.com/labels/7/docs/1741387668314126)。</description><guid isPermaLink="true">https://night1008.github.io/post/bu-tong-guang-gao-qu-dao-bao-biao-lei-xing-ji-bie-de-dui-ying-guan-xi.html</guid><pubDate>Thu, 06 Mar 2025 03:18:06 +0000</pubDate></item><item><title>Clickhouse 如何实现间隔分析</title><link>https://night1008.github.io/post/Clickhouse%20-ru-he-shi-xian-jian-ge-fen-xi.html</link><description>通过间隔分析查看转化时长的分布情况。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20-ru-he-shi-xian-jian-ge-fen-xi.html</guid><pubDate>Fri, 28 Feb 2025 07:55:12 +0000</pubDate></item><item><title>Clickhouse arrayJoin 数组字段无值被过滤问题</title><link>https://night1008.github.io/post/Clickhouse%20arrayJoin%20-shu-zu-zi-duan-wu-zhi-bei-guo-lv-wen-ti.html</link><description>Clickhouse 使用 arrayJoin 展开数组字段时，有些数组字段可能是没有值的，这时候这些记录会被过滤掉，如下所示，

```sql
select *, arrayJoin(a) as b_item from (
  select array(1, 2, 3) as a, 1 as b
  union all
  select array(1) as a, 2 as b
  union all
  select array() as a, 3 as b
)

   ┌─a───────┬─b─┬─b_item─┐
1. │ [1,2,3] │ 1 │      1 │
2. │ [1,2,3] │ 1 │      2 │
3. │ [1,2,3] │ 1 │      3 │
   └─────────┴───┴────────┘
   ┌─a───┬─b─┬─b_item─┐
4. │ [1] │ 2 │      1 │
   └─────┴───┴────────┘
```

---

解决方法如下

```sql
select *, arrayJoin(if(empty(a), [null], a)) as b_item from (
  select array(1, 2, 3) as a, 1 as b
  union all
  select array(1) as a, 2 as b
  union all
  select array() as a, 3 as b
)

   ┌─a───┬─b─┬─b_item─┐
1. │ [1] │ 2 │      1 │
   └─────┴───┴────────┘
   ┌─a───────┬─b─┬─b_item─┐
2. │ [1,2,3] │ 1 │      1 │
3. │ [1,2,3] │ 1 │      2 │
4. │ [1,2,3] │ 1 │      3 │
   └─────────┴───┴────────┘
   ┌─a──┬─b─┬─b_item─┐
5. │ [] │ 3 │   ᴺᵁᴸᴸ │
   └────┴───┴────────┘
```

```sql
select *, arrayJoin(range(1, length(if(empty(a), [null], a)) + 1)) AS b_item_index from (
  select array(1, 2, 3) as a, 1 as b
  union all
  select array(1) as a, 2 as b
  union all
  select array() as a, 3 as b
)

   ┌─a───┬─b─┬─b_item_index─┐
1. │ [1] │ 2 │            1 │
   └─────┴───┴──────────────┘
   ┌─a──┬─b─┬─b_item_index─┐
2. │ [] │ 3 │            1 │
   └────┴───┴──────────────┘
   ┌─a───────┬─b─┬─b_item_index─┐
3. │ [1,2,3] │ 1 │            1 │
4. │ [1,2,3] │ 1 │            2 │
5. │ [1,2,3] │ 1 │            3 │
   └─────────┴───┴──────────────┘
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20arrayJoin%20-shu-zu-zi-duan-wu-zhi-bei-guo-lv-wen-ti.html</guid><pubDate>Thu, 27 Feb 2025 03:52:03 +0000</pubDate></item><item><title>使用 PostgreSQL + PostgREST 加快后端开发</title><link>https://night1008.github.io/post/shi-yong-%20PostgreSQL%20%2B%20PostgREST%20-jia-kuai-hou-duan-kai-fa.html</link><description>使用 PostgreSQL + PostgREST，可以省去大部分后端编写工作。</description><guid isPermaLink="true">https://night1008.github.io/post/shi-yong-%20PostgreSQL%20%2B%20PostgREST%20-jia-kuai-hou-duan-kai-fa.html</guid><pubDate>Sun, 23 Feb 2025 03:28:02 +0000</pubDate></item><item><title>Visual Studio Code 插件列表</title><link>https://night1008.github.io/post/Visual%20Studio%20Code%20-cha-jian-lie-biao.html</link><description>1. [Git Stash](https://marketplace.visualstudio.com/items?itemName=arturock.gitstash)。</description><guid isPermaLink="true">https://night1008.github.io/post/Visual%20Studio%20Code%20-cha-jian-lie-biao.html</guid><pubDate>Sat, 25 Jan 2025 04:41:05 +0000</pubDate></item><item><title>通用业务使用手册</title><link>https://night1008.github.io/post/tong-yong-ye-wu-shi-yong-shou-ce.html</link><description>### 数据库表标识字段生成规则

正常数据库记录有自增的数字ID，另外有些记录还需要生成英文标识字段

比如现在`应用`表要增加一个`标识`字段，
不要使用中文转拼音的方式，比如 `数据测试` =&gt; `shu_ju_ce_shi_d4qbfwuf`
可以使用 **固定长度的唯一字符串**，比如 `app_t07o2yt58p`

优点：后续改名称可以不用去管标识字段内容

---

### 业务关键步骤打印日志

比如以任务执行为例，在任务开始，任务阶段1，任务阶段2，... 任务阶段N，任务结束都可以打印一些关键信息

优点：方便查看执行情况和后续定位问题

---

### 数据库字段名称命名规则

1. 小写字母 + 下划线
&gt; 字段名称中只能包含字母、数字和下划线 _
&gt; 比如 user_id, created_at, first_name
&gt; 不使用驼峰命名法，因为某些数据库（如 PostgreSQL）默认将字段名称转换为小写，可能导致问题

2. 使用前缀来区分字段类型或用途
&gt; 使用 is_ 或 has_ 前缀表示布尔值，比如，is_active：是否激活；has_permission：是否有权限
&gt; 比如为了区分系统预置和用户自定义，可以对预置属性增加 pre_ 的前缀

3. 避免特殊字符
&gt; 尽量不要使用如 #, $, _ 的前缀，以免出现通过字段名称构建路径的问题。</description><guid isPermaLink="true">https://night1008.github.io/post/tong-yong-ye-wu-shi-yong-shou-ce.html</guid><pubDate>Thu, 16 Jan 2025 07:35:10 +0000</pubDate></item><item><title>Clickhouse 业务使用手册</title><link>https://night1008.github.io/post/Clickhouse%20-ye-wu-shi-yong-shou-ce.html</link><description>### 指定周任意起始日
```sql
select arrayJoin([0,1,2,3,4,5,6]) as start_day, 
  toDateTime('2025-04-10') as t,
  toDayOfWeek(t),
  if(start_day &lt;= toDayOfWeek(t), 
     date_add(DAY, -((toDayOfWeek(t) - start_day) % 7), t),
     date_add(DAY, -7-((toDayOfWeek(t) - start_day) % 7), t)
  ) AS week_start_day;
```
---

### 时间戳转时间
```sql
select `#time`, timestamp_add(fromUnixTimestamp64Milli(`#time`), interval coalesce(`#zone_offset`, 8) * 60 minute) from events where `#event` = '#device_login' and `#dt` = '2025-03-01' limit 100;
```
---

### 变更语句是否执行完
```sql
select hostname(),* from clusterAllReplicas('default','system.mutations') where is_done = 0;
```

---

### 加快字段删除速度
```sql
-- 每次变更之前执行
alter table demo.users_local modify setting number_of_free_entries_in_pool_to_execute_mutation = 1;

-- 变更完成后执行
alter table demo.users_local reset setting number_of_free_entries_in_pool_to_execute_mutation;
```

---

### 清理数据库表
```sql
truncate table demo.events_local;
truncate table demo_global.users_local;
truncate table demo_global.devices_local;
```
---

### 根据 query 查询 clickhouse 日志
```sql
select * from cluster('all-sharded', 'system', 'query_log') where query_id  = '4efbbb9b-b853-44ca-84b2-95ff066895af';
```
---

### 数据导出成CSV
```sql
SELECT * FROM events
SETTINGS join_use_nulls=1, allow_experimental_analyzer=0
INTO OUTFILE '新玩家首日首场战场数据.csv.gz' TRUNCATE
FORMAT CSVWithNames;
```
---

### 数据去重验证
```sql
select `_part`, `#dt`, `#event`, `#log_id`, count(1), groupArray(hostname()) from events where `#dt` = '2024-07-28' group by 1, 2, 3, 4 order by 5 desc limit 100;
```

---

### 查询表大小
```sql
SELECT database,  table, formatReadableSize(sum(bytes_on_disk)) AS size_on_disk
FROM system.parts
WHERE active
GROUP BY database, table
ORDER BY sum(bytes_on_disk) DESC;
```

---

### 删除分区数据(本地表)
```sql
DELETE FROM table_local WHERE date = '2025-10-01';
```
。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20-ye-wu-shi-yong-shou-ce.html</guid><pubDate>Mon, 13 Jan 2025 06:43:46 +0000</pubDate></item><item><title>分布分析中如何划分区间</title><link>https://night1008.github.io/post/fen-bu-fen-xi-zhong-ru-he-hua-fen-qu-jian.html</link><description>### 问题&#13;
分布分析中需要根据某一步长对一组值进行区间划分，且其包含正负数。</description><guid isPermaLink="true">https://night1008.github.io/post/fen-bu-fen-xi-zhong-ru-he-hua-fen-qu-jian.html</guid><pubDate>Fri, 10 Jan 2025 06:30:43 +0000</pubDate></item><item><title>Clickhouse Golang 从缓存中读取时间类型字段丢失时区的问题</title><link>https://night1008.github.io/post/Clickhouse%20Golang%20-cong-huan-cun-zhong-du-qu-shi-jian-lei-xing-zi-duan-diu-shi-shi-qu-de-wen-ti.html</link><description>### 背景&#13;
&#13;
使用以下两个包进行 clickhouse 查询数据缓存，发现命中缓存时，返回的时间类型字段的值偏移了八个小时，服务器时区是零时区&#13;
- https://github.com/ClickHouse/clickhouse-go&#13;
- https://github.com/night1008/sqlcache&#13;
&#13;
### 问题原因&#13;
直接通过数据库查询的时间是东八区，比如 `2024-12-05 00:00:05.657 +0800 CST`，&#13;
但是后面命中缓存从中拿到的时区是零时区(服务器时区是零时区)，比如 `2024-12-04 16:00:05.657 +0000 UTC`，&#13;
这样再对时间字段做格式化的时候就会差了八个时区，&#13;
不过这时候缓存已丢失了最开始查询所携带的时区&#13;
&#13;
### 解决方法&#13;
1. 缓存查询数据的同时，缓存列的信息，来自 sql.DatabaseTypeName()，比如 DateTime64(3, 'Asia/Shanghai')&#13;
2. 查询命中缓存时通过解析列信息列得到时区&#13;
3. 对时间字段指定解析后的时区进行格式化&#13;
&#13;
不过本质原因是缓存包使用 `msgpack` 进行序列化，该方式没有保存时区信息，  &#13;
因此还可以有其他的解决方法，&#13;
1. 寻找`msgpack` 关于时间类型的扩展&#13;
2. 实现新的缓存包的接口，使用其他序列化方式，比如 `json`&#13;
&#13;
---&#13;
&#13;
发现一个有意思的现象，通过 `union` 的方式查询两条不同时区的数据，后续的数据都会转换成第一条数据所拥有的时区。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20Golang%20-cong-huan-cun-zhong-du-qu-shi-jian-lei-xing-zi-duan-diu-shi-shi-qu-de-wen-ti.html</guid><pubDate>Mon, 06 Jan 2025 07:09:51 +0000</pubDate></item><item><title>Go 全局时区设置</title><link>https://night1008.github.io/post/Go%20-quan-ju-shi-qu-she-zhi.html</link><description>正常本地开发环境的时区是东八区，线上服务器的时区是零时区，  &#13;
调试一些线上服务器的时区问题的时候，如何通过设置全局时区在本地进行调试呢。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-quan-ju-shi-qu-she-zhi.html</guid><pubDate>Mon, 06 Jan 2025 02:08:02 +0000</pubDate></item><item><title>PostgreSQL 业务使用手册</title><link>https://night1008.github.io/post/PostgreSQL%20-ye-wu-shi-yong-shou-ce.html</link><description>### 只读账号授权
```sql
GRANT CONNECT ON DATABASE demo_web TO demo_web_ro;

GRANT USAGE ON SCHEMA public TO demo_web_ro;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO demo_web_ro;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO demo_web_ro;
```

---

### 手动修改联合主键表索引

原本 `ad_advertisers` 表以 `app_id`, `channel_name`, `account_id` 三个字段为主键，现在如何往中间再加一个主键字段

```sql
CREATE UNIQUE INDEX ad_advertisers_pkey ON public.ad_advertisers USING btree (app_id, channel_name, account_id);

=&gt;

ALTER TABLE public.ad_advertisers DROP CONSTRAINT ad_advertisers_pkey;
UPDATE ad_advertisers SET account_type = '' WHERE account_type IS NULL;
ALTER TABLE public.ad_advertisers ADD CONSTRAINT ad_advertisers_pkey PRIMARY KEY (app_id, channel_name, account_type, account_id);
```

---

### 重置数据库表 ID

```sql
ALTER SEQUENCE users_id_seq RESTART WITH 7;

-- 根据表已有的数据进行重置
SELECT setval('users_id_seq', (SELECT coalesce(max(id), 0) FROM users));
```

---

### 查看表结构

```sql
pg_dump -h localhost -p 5432 -U postgres -d db_name -t table_name --schema-only
```

---

### 表大小情况查询

```sql
-- 查看每个表的占用空间大小
select
  table_name, 
  pg_size_pretty(pg_total_relation_size(quote_ident(table_name))),
  pg_size_pretty(pg_relation_size(quote_ident(table_name)))
from information_schema.tables
where table_schema = 'public'
order by pg_total_relation_size(quote_ident(table_name)) desc;

-- 查看每个表的行数
SELECT 
    schemaname AS schema,
    relname AS table,
    n_live_tup AS estimated_row_count
FROM 
    pg_stat_user_tables
ORDER BY 3 desc;

-- 查看某个数据库磁盘占用情况
select pg_size_pretty(pg_database_size('funnydb_web'));

-- 查看全部数据库磁盘占用情况
SELECT datname as db_name, pg_size_pretty(pg_database_size(datname)) as db_usage FROM pg_database order by pg_database_size(datname) desc;
```

---

### 查询列的字段类型
```sql
select pg_typeof('column1'), pg_typeof('column2') from table1;
```

---

### 文本类型字段的数字匹配
```sql
SELECT value, value::numeric FROM property_values where value ~ '^[-0-9.]+$' limit 1000;

select min(id) from (select '10005' as id union all select '995' as id);  -- 错误写法
```

---

### 复制表
```sql
create table users_old as (select * from users);
```

---

### 计算列（Generated Columns）
PostgreSQL 12+ 支持生成列（Generated Columns），这些列的值会自动计算并存储：

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    price DECIMAL(10,2),
    quantity INTEGER,
    total_price DECIMAL(10,2) GENERATED ALWAYS AS (price * quantity) STORED
);
```
STORED 表示值会被实际存储（物化），而不是每次查询时计算。</description><guid isPermaLink="true">https://night1008.github.io/post/PostgreSQL%20-ye-wu-shi-yong-shou-ce.html</guid><pubDate>Thu, 26 Dec 2024 06:22:19 +0000</pubDate></item><item><title>分布式任务调度设计要点</title><link>https://night1008.github.io/post/fen-bu-shi-ren-wu-diao-du-she-ji-yao-dian.html</link><description>设计要点：&#13;
1. 任务函数注册方便，参考 http 函数注册&#13;
2. 任务创建可以指定参数，比如重试次数，延迟执行，超时时间等&#13;
3. 任务可以分队列，避免阻塞，比如高中低优先级&#13;
4. 任务执行 worker 数量可以任意扩展&#13;
5. 支持指定定时任务，定时任务的产生可以通过数据库生成，这样方便修改任务信息&#13;
6. 相同定时任务可以指定不同定时时间，不同时区&#13;
&#13;
因为业务上有定时任务的场景，之前思考如何使用 redis 达到上面的设计要点时，一直没想通怎么做，  &#13;
直到看到 https://github.com/hibiken/asynq 的实现，没想到可以通过外部定时器发送定时任务的方式达到效果。</description><guid isPermaLink="true">https://night1008.github.io/post/fen-bu-shi-ren-wu-diao-du-she-ji-yao-dian.html</guid><pubDate>Thu, 19 Dec 2024 06:48:23 +0000</pubDate></item><item><title>Go Gorm 如何查询动态字段列表且能更新查询后的结果数据</title><link>https://night1008.github.io/post/Go%20Gorm%20-ru-he-cha-xun-dong-tai-zi-duan-lie-biao-qie-neng-geng-xin-cha-xun-hou-de-jie-guo-shu-ju.html</link><description>### 背景&#13;
&#13;
最近广告业务上的一些报表查询接口，需要根据前端指定的字段列表返回查询聚合结果，其中某些字段不方便在数据库中直接查询得到，需要经过服务端二次计算，才能得到最终结果。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20Gorm%20-ru-he-cha-xun-dong-tai-zi-duan-lie-biao-qie-neng-geng-xin-cha-xun-hou-de-jie-guo-shu-ju.html</guid><pubDate>Fri, 29 Nov 2024 03:30:08 +0000</pubDate></item><item><title>Go web application packages</title><link>https://night1008.github.io/post/Go%20web%20application%20packages.html</link><description>1. [github.com/gin-gonic/gin](https://github.com/gin-gonic/gin) (framework)&#13;
2. [github.com/spf13/cobra](https://github.com/spf13/cobra) (cli)&#13;
3. [github.com/spf13/viper](https://github.com/spf13/viper) (config)&#13;
4. [gorm.io/gorm](https://gorm.io/gorm) (orm)&#13;
5. [github.com/rs/zerolog](https://github.com/rs/zerolog) (log)。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20web%20application%20packages.html</guid><pubDate>Wed, 13 Nov 2024 05:54:43 +0000</pubDate></item><item><title>关于 Golang viper mapstructure 反序列化多次数组类型输出错误</title><link>https://night1008.github.io/post/guan-yu-%20Golang%20viper%20mapstructure%20-fan-xu-lie-hua-duo-ci-shu-zu-lei-xing-shu-chu-cuo-wu.html</link><description>业务程序使用了 Golang 中的 [viper](github.com/spf13/viper) 进行加载配置，&#13;
但在实际使用过程中因为读取了两次配置，同时反序列化了两次，&#13;
导致一些数组类型的字段出现了不符合预期的结果，如下测试程序所示。</description><guid isPermaLink="true">https://night1008.github.io/post/guan-yu-%20Golang%20viper%20mapstructure%20-fan-xu-lie-hua-duo-ci-shu-zu-lei-xing-shu-chu-cuo-wu.html</guid><pubDate>Fri, 01 Nov 2024 02:56:12 +0000</pubDate></item><item><title>PostgreSQL 持有行级别锁后表字段变更失败的问题</title><link>https://night1008.github.io/post/PostgreSQL%20-chi-you-xing-ji-bie-suo-hou-biao-zi-duan-bian-geng-shi-bai-de-wen-ti.html</link><description>### 背景&#13;
&#13;
我们使用了 `PostgreSQL` 表的记录作为任务只在单个节点上执行的全局锁，&#13;
并且使用的是 `FOR UPDATE` 的行级别锁，&#13;
但在锁已被表持有的情况下，如果要对表结构进行变更字段的话，会执行失败，&#13;
场景为旧部署服务已持有了行级别锁，新部署服务就变更不了表结构，&#13;
因为 DDL 操作（如添加列）会对整个表加锁，这两者发生了冲突。</description><guid isPermaLink="true">https://night1008.github.io/post/PostgreSQL%20-chi-you-xing-ji-bie-suo-hou-biao-zi-duan-bian-geng-shi-bai-de-wen-ti.html</guid><pubDate>Thu, 10 Oct 2024 09:59:24 +0000</pubDate></item><item><title>Clickhouse 如何实现 LTV 分析</title><link>https://night1008.github.io/post/Clickhouse%20-ru-he-shi-xian-%20LTV%20-fen-xi.html</link><description>### 背景&#13;
&#13;
LTV 是 Life Time Value 缩写，即用户在生命周期中贡献的商业价值。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20-ru-he-shi-xian-%20LTV%20-fen-xi.html</guid><pubDate>Wed, 09 Oct 2024 02:41:30 +0000</pubDate></item><item><title>如何通过数据库全局锁方式实现任务单节点执行</title><link>https://night1008.github.io/post/ru-he-tong-guo-shu-ju-ku-quan-ju-suo-fang-shi-shi-xian-ren-wu-dan-jie-dian-zhi-xing.html</link><description>通过 `postgres` 的数据库行级别的锁机制全局控制所有的任务只在某个节点上执行&#13;
&#13;
```go&#13;
package main&#13;
&#13;
import (&#13;
	'context'&#13;
	'errors'&#13;
	'log'&#13;
	'time'&#13;
&#13;
	'github.com/jackc/pgconn'&#13;
	'golang.org/x/sync/errgroup'&#13;
	'gorm.io/driver/postgres'&#13;
	'gorm.io/gorm'&#13;
	'gorm.io/gorm/clause'&#13;
	'gorm.io/gorm/logger'&#13;
)&#13;
&#13;
const (&#13;
	globalJobLockGetPollingDuration = time.Second // 全局任务锁轮询时间&#13;
&#13;
	ServiceDeploymentNameGlobalJobLock = 'global-job-lock' // 全局任务锁&#13;
)&#13;
&#13;
type ServiceDeployment struct {&#13;
	Name string `gorm:'primarykey'` // 服务名称&#13;
&#13;
	CreatedAt int64 `gorm:'autoCreateTime:milli'` // 记录创建时间，单位 milli&#13;
	UpdatedAt int64 `gorm:'autoUpdateTime:milli'` // 记录更新时间，单位 milli&#13;
}&#13;
&#13;
func main() {&#13;
	dsn := 'host=localhost user=postgres password=secret dbname=test port=5432 sslmode=disable'&#13;
	db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})&#13;
	if err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
	if err := db.AutoMigrate(&amp;ServiceDeployment{}); err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
&#13;
	var jobEnable bool&#13;
&#13;
	eg, ctx := errgroup.WithContext(context.Background())&#13;
	eg.Go(func() error {&#13;
		ticker := time.NewTicker(globalJobLockGetPollingDuration)&#13;
		defer ticker.Stop()&#13;
&#13;
		for {&#13;
			exist, err := GetGlobalJobLock(db)&#13;
			if err != nil {&#13;
				log.Println(err)&#13;
			}&#13;
			if exist {&#13;
				jobEnable = true&#13;
				break&#13;
			}&#13;
&#13;
			select {&#13;
			case &lt;-ctx.Done():&#13;
				return ctx.Err()&#13;
			case &lt;-ticker.C:&#13;
			}&#13;
		}&#13;
		return nil&#13;
	})&#13;
&#13;
	eg.Go(func() error {&#13;
		if err := stopTickerUntil(ctx, globalJobLockGetPollingDuration, func() bool {&#13;
			return jobEnable&#13;
		}); err != nil {&#13;
			return err&#13;
		}&#13;
		return RunJob(ctx)&#13;
	})&#13;
&#13;
	if err := eg.Wait(); err != nil {&#13;
		log.Println(err)&#13;
	}&#13;
}&#13;
&#13;
func FindOne(db *gorm.DB, out interface{}) (bool, error) {&#13;
	result := db.First(out)&#13;
	if err := result.Error; err != nil {&#13;
		if errors.Is(err, gorm.ErrRecordNotFound) {&#13;
			return false, nil&#13;
		}&#13;
		return false, err&#13;
	}&#13;
	return true, nil&#13;
}&#13;
&#13;
func GetGlobalJobLock(db *gorm.DB) (bool, error) {&#13;
	deployment := ServiceDeployment{&#13;
		Name: ServiceDeploymentNameGlobalJobLock,&#13;
	}&#13;
	if err := db.FirstOrCreate(&amp;deployment, ServiceDeployment{Name: ServiceDeploymentNameGlobalJobLock}).Error; err != nil {&#13;
		return false, err&#13;
	}&#13;
&#13;
	tx := db.Session(&amp;gorm.Session{Logger: logger.Discard}).Begin() // 不打印错误日志，拿到锁会占用一个数据库连接&#13;
	exist, err := FindOne(tx.Clauses(clause.Locking{Strength: 'UPDATE', Options: 'NOWAIT'}).Where('name = ?', ServiceDeploymentNameGlobalJobLock), &amp;deployment)&#13;
	if err != nil {&#13;
		if pgErr, ok := err.(*pgconn.PgError); ok &amp;&amp; pgErr.Code == '55P03' {&#13;
			err = nil&#13;
		}&#13;
		_ = tx.Rollback()&#13;
	}&#13;
	return exist, err&#13;
}&#13;
&#13;
func stopTickerUntil(ctx context.Context, duration time.Duration, stopFunc func() bool) error {&#13;
	ticker := time.NewTicker(duration)&#13;
	defer ticker.Stop()&#13;
&#13;
Loop:&#13;
	for {&#13;
		select {&#13;
		case &lt;-ctx.Done():&#13;
			return ctx.Err()&#13;
		case &lt;-ticker.C:&#13;
			if stopFunc() {&#13;
				break Loop&#13;
			}&#13;
		}&#13;
	}&#13;
	return nil&#13;
}&#13;
&#13;
func RunJob(ctx context.Context) error {&#13;
	// run job&#13;
	return nil&#13;
}&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-tong-guo-shu-ju-ku-quan-ju-suo-fang-shi-shi-xian-ren-wu-dan-jie-dian-zhi-xing.html</guid><pubDate>Fri, 27 Sep 2024 07:01:48 +0000</pubDate></item><item><title>Clickhouse 留存分析中如何计算分析主体的留存情况</title><link>https://night1008.github.io/post/Clickhouse%20-liu-cun-fen-xi-zhong-ru-he-ji-suan-fen-xi-zhu-ti-de-liu-cun-qing-kuang.html</link><description>## 背景&#13;
&#13;
先明确留存分析相关的概念，&#13;
**留存分析**：衡量不同批次新增用户的数据表现，最常见的就是留存率&#13;
**分析主体**：触发事件的主体，比如用户&#13;
**初始事件**：代表新增的事件，比如用户注册&#13;
**回访事件**：代表活跃的事件，比如用户登录&#13;
**回访用户同时参与事件**：代表活跃的事件，比如用户充值&#13;
&#13;
## 需求&#13;
&#13;
产品给出的关于留存定义为：**某天完成了初始事件的分析主体，在初始事件日期后的第 1 日至第 N 日有完成“回访事件”，即为第 N 日的“留存用户”**。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20-liu-cun-fen-xi-zhong-ru-he-ji-suan-fen-xi-zhu-ti-de-liu-cun-qing-kuang.html</guid><pubDate>Thu, 12 Sep 2024 09:49:38 +0000</pubDate></item><item><title>Clickhouse 留存分析中如何计算分析主体的流失数</title><link>https://night1008.github.io/post/Clickhouse%20-liu-cun-fen-xi-zhong-ru-he-ji-suan-fen-xi-zhu-ti-de-liu-shi-shu.html</link><description>### 背景&#13;
&#13;
先明确留存分析相关的概念&#13;
**留存分析**：衡量不同批次新增用户的数据表现，最常见的就是留存率&#13;
**分析主体**：触发事件的主体，比如用户&#13;
**初始事件**：代表新增的事件，比如用户注册&#13;
**回访事件**：代表活跃的事件，比如用户登录&#13;
&#13;
---&#13;
&#13;
### 需求&#13;
&#13;
产品给出的流失定义为：某天完成了初始事件的分析主体，在初始事件日期后的第 1 日至第 N 日都没有完成“回访事件”，即为第 N 日的“流失用户”。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20-liu-cun-fen-xi-zhong-ru-he-ji-suan-fen-xi-zhu-ti-de-liu-shi-shu.html</guid><pubDate>Mon, 19 Aug 2024 08:25:07 +0000</pubDate></item><item><title>看过的电影合集</title><link>https://night1008.github.io/post/kan-guo-de-dian-ying-he-ji.html</link><description>电影链接到 [豆瓣电影](https://movie.douban.com)
---

- [九龙城寨之围城](https://movie.douban.com/subject/24284175) (一般)
- [年会不能停](https://movie.douban.com/subject/35725869) (还可以)
- [三大队](https://movie.douban.com/subject/35208463) (还可以)
- [孤注一掷](https://movie.douban.com/subject/35267224) (还可以)
- [瀑布](https://movie.douban.com/subject/35242938) (还可以)
- [周处除三害](https://movie.douban.com/subject/36151692) (还可以)
- [老狐狸](https://movie.douban.com/subject/35611467) (不错)
- [破墓](https://movie.douban.com/subject/35490167) (还可以)
- [首](https://movie.douban.com/subject/35359717) (还可以)
- [沙丘1](https://movie.douban.com/subject/3001114) (还可以)
- [沙丘2](https://movie.douban.com/subject/35575567) (还可以)
- [月满轩尼诗](https://movie.douban.com/subject/3777800) (还可以)
- [因果报应 Maharaja](https://movie.douban.com/subject/36934908/) (还不错)
- [心里的声音](https://movie.douban.com/subject/26435723/) (还可以)
- [椒麻堂会](https://movie.douban.com/subject/27305997/) (有点意思)
- [射雕英雄传：侠之大者](https://m.douban.com/movie/subject/36289423/) (不行)
- [哪吒之魔童闹海](https://movie.douban.com/subject/34780991/)(还不错)
- [唐探1900](https://movie.douban.com/subject/36282639/) (前面有点无聊)
- [戏台](https://movie.douban.com/subject/35483395/) (还不错)
- [大空头](https://movie.douban.com/subject/26303622/) (还行)
- [长安的荔枝](https://movie.douban.com/subject/36185502/) (还行)
- [罗小黑战记2](https://movie.douban.com/subject/36448279/) (2025-10-26，还行)
- [浪浪山小妖怪](https://movie.douban.com/subject/36438475/) (2025-11-22，还不错)。</description><guid isPermaLink="true">https://night1008.github.io/post/kan-guo-de-dian-ying-he-ji.html</guid><pubDate>Sat, 06 Jul 2024 14:59:53 +0000</pubDate></item><item><title>Go recover from panic</title><link>https://night1008.github.io/post/Go%20recover%20from%20panic.html</link><description>```go&#13;
package main&#13;
&#13;
import (&#13;
	'fmt'&#13;
	'runtime/debug'&#13;
	'time'&#13;
&#13;
	'github.com/rs/zerolog/log'&#13;
)&#13;
&#13;
func Recover() {&#13;
	if r := recover(); r != nil {&#13;
		debugStack := string(debug.Stack())&#13;
		fmt.Println(debugStack)&#13;
		log.Error().Err(fmt.Errorf('%s', debugStack)).Msg('recover from panic')&#13;
	}&#13;
}&#13;
&#13;
func main() {&#13;
	go func() {&#13;
		defer Recover()&#13;
		var ss []string&#13;
		fmt.Println(ss[1])&#13;
	}()&#13;
&#13;
	time.Sleep(100 * time.Millisecond)&#13;
&#13;
	fmt.Println('===&gt; enter end')&#13;
}&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20recover%20from%20panic.html</guid><pubDate>Fri, 05 Jul 2024 09:30:36 +0000</pubDate></item><item><title>Go 如何实现事件分析分组排序</title><link>https://night1008.github.io/post/Go%20-ru-he-shi-xian-shi-jian-fen-xi-fen-zu-pai-xu.html</link><description>事件分析过程中，会对分组进行排序，有如下的排序规则，&#13;
&#13;
1. 按第一个指标值的正序排列&#13;
2. 按第一个指标值的倒序排列&#13;
3. 按分组值的正序排列&#13;
4. 按分组值的倒序排列&#13;
&#13;
分组是 `[][]string` 类型，值是 `float64` 类型，&#13;
&#13;
下面记录下主要的排序代码&#13;
&#13;
```go&#13;
const (&#13;
	PropertyTypeInteger              = 'integer'                // 整数类型&#13;
	PropertyTypeFloat                = 'float'                  // 浮点类型，对应 float64 或 double&#13;
	PropertyTypeNumber               = 'number'                 // 浮点类型，对应 float64 或 double&#13;
)&#13;
&#13;
type EventModelQueryGroupBy struct {&#13;
	Name              string    `json:'name' example:'_time'`&#13;
	Type              string    `json:'type' example:'timestamp'`&#13;
	Title             string    `json:'title' example:'事件发生时间'`&#13;
	TableType         string    `json:'table_type' example:'event'`&#13;
	MetaType          string    `json:'meta_type' example:'custom'`&#13;
}&#13;
&#13;
// 根据分组值排序&#13;
func sortUnionGroupsByValue(unionGroups [][]string, unionGroupsValueMap map[string]float64, unionGroupsJoinSymbol string, sortByAsc bool) [][]string {&#13;
	newUnionGroups := make([][]string, len(unionGroups))&#13;
	copy(newUnionGroups, unionGroups)&#13;
	sort.Slice(newUnionGroups, func(i, j int) bool {&#13;
		sortValue := false&#13;
		if sortByAsc {&#13;
			sortValue = unionGroupsValueMap[strings.Join(newUnionGroups[i], unionGroupsJoinSymbol)] &lt; unionGroupsValueMap[strings.Join(newUnionGroups[j], unionGroupsJoinSymbol)]&#13;
		} else {&#13;
			sortValue = unionGroupsValueMap[strings.Join(newUnionGroups[i], unionGroupsJoinSymbol)] &gt; unionGroupsValueMap[strings.Join(newUnionGroups[j], unionGroupsJoinSymbol)]&#13;
		}&#13;
		return sortValue&#13;
	})&#13;
	return newUnionGroups&#13;
}&#13;
&#13;
// 根据分组名称排序&#13;
func sortUnionGroupsByGroup(unionGroups [][]string, unionGroupBy []*EventModelQueryGroupBy, sortByAsc bool) [][]string {&#13;
	newUnionGroups := make([][]string, len(unionGroups))&#13;
	copy(newUnionGroups, unionGroups)&#13;
	sort.Slice(newUnionGroups, func(i, j int) bool {&#13;
		sortValue := false&#13;
		for index := range unionGroupBy {&#13;
			if newUnionGroups[i][index] != newUnionGroups[j][index] {&#13;
				switch unionGroupBy[index].Type {&#13;
				case PropertyTypeInteger, PropertyTypeNumber:&#13;
					if sortByAsc {&#13;
						sortValue = sortValue || parseNumberRangeSortValue(newUnionGroups[i][index]) &lt; parseNumberRangeSortValue(newUnionGroups[j][index])&#13;
					} else {&#13;
						sortValue = sortValue || parseNumberRangeSortValue(newUnionGroups[i][index]) &gt; parseNumberRangeSortValue(newUnionGroups[j][index])&#13;
					}&#13;
				default:&#13;
					if sortByAsc {&#13;
						sortValue = sortValue || newUnionGroups[i][index] &lt; newUnionGroups[j][index]&#13;
					} else {&#13;
						sortValue = sortValue || newUnionGroups[i][index] &gt; newUnionGroups[j][index]&#13;
					}&#13;
				}&#13;
				break&#13;
			}&#13;
		}&#13;
		return sortValue&#13;
	})&#13;
	return newUnionGroups&#13;
}&#13;
&#13;
// 对数值类型分组值拆分得到排序值 [-∞, 100), [-1, 2), 100, (null)&#13;
func parseNumberRangeSortValue(valueStr string) float64 {&#13;
	firstPartValue := strings.SplitN(valueStr, ',', 2)[0]&#13;
	firstPartValue = strings.TrimLeft(firstPartValue, '[')&#13;
	switch firstPartValue {&#13;
	case '-∞':&#13;
		return math.Inf(-1)&#13;
	case '(null)':&#13;
		return math.NaN()&#13;
	default:&#13;
		value, err := strconv.ParseFloat(firstPartValue, 64)&#13;
		if err != nil {&#13;
			return math.Inf(-1)&#13;
		}&#13;
		return value&#13;
	}&#13;
}&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-ru-he-shi-xian-shi-jian-fen-xi-fen-zu-pai-xu.html</guid><pubDate>Thu, 04 Jul 2024 07:01:03 +0000</pubDate></item><item><title>Go mod 如何替换 fork 的包和版本</title><link>https://night1008.github.io/post/Go%20mod%20-ru-he-ti-huan-%20fork%20-de-bao-he-ban-ben.html</link><description>以  `github.com/prashanthpai/sqlcache` 为例，想替换成 fork 的包 `github.com/night1008/sqlcache`，&#13;
假设当前该包的版本为 `v0.0.0`&#13;
&#13;
#### 第一步&#13;
```&#13;
go mod edit -replace github.com/prashanthpai/sqlcache@v0.0.0=github.com/night1008/sqlcache@master&#13;
```&#13;
&#13;
---&#13;
&#13;
#### 第二步&#13;
```&#13;
go get -u github.com/night1008/sqlcache&#13;
```&#13;
&#13;
会有以下提示&#13;
```&#13;
go: downloading github.com/night1008/sqlcache v0.0.0-20240623031410-4d47c940a2d7&#13;
go: github.com/night1008/sqlcache@v0.0.0-20240623031410-4d47c940a2d7: parsing go.mod:&#13;
	module declares its path as: github.com/prashanthpai/sqlcache&#13;
	        but was required as: github.com/night1008/sqlcache&#13;
```&#13;
&#13;
---&#13;
&#13;
#### 第三步&#13;
&#13;
手动把 v0.0.0-20240623031410-4d47c940a2d7 替换到 go.mod `replace github.com/prashanthpai/sqlcache v0.0.0 =&gt; github.com/night1008/sqlcache master` 这一行的 master&#13;
&#13;
---&#13;
&#13;
#### 第四步&#13;
```&#13;
go mod tidy&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20mod%20-ru-he-ti-huan-%20fork%20-de-bao-he-ban-ben.html</guid><pubDate>Wed, 26 Jun 2024 06:52:27 +0000</pubDate></item><item><title>如何使用 GORM 创建或者更新数据库记录</title><link>https://night1008.github.io/post/ru-he-shi-yong-%20GORM%20-chuang-jian-huo-zhe-geng-xin-shu-ju-ku-ji-lu.html</link><description>写业务过程中，经过会遇到当数据不存在则创建记录，已存在则更新记录的情况，&#13;
&#13;
一开始使用一下代码中的第一种方式，发现没生效，后面改成第二种才生效，在此记录一下。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-shi-yong-%20GORM%20-chuang-jian-huo-zhe-geng-xin-shu-ju-ku-ji-lu.html</guid><pubDate>Sat, 22 Jun 2024 04:12:24 +0000</pubDate></item><item><title>Go 如何实现 Clickhouse 查询缓存</title><link>https://night1008.github.io/post/Go%20-ru-he-shi-xian-%20Clickhouse%20-cha-xun-huan-cun.html</link><description>**整体思路：先判断是否命中缓存，没有的话再进入查询队列**&#13;
&#13;
依赖的包&#13;
```&#13;
https://github.com/ClickHouse/ClickHouse&#13;
&#13;
https://github.com/prashanthpai/sqlcache =&gt; https://github.com/night1008/sqlcache&#13;
&#13;
https://github.com/DATA-DOG/go-sqlmock&#13;
&#13;
https://github.com/blockloop/scan&#13;
```&#13;
&#13;
现在的问题是 clickhouse 的查询结果可能返回复杂类型，比如 Map(String, UInt8)，&#13;
如果命中缓存，缓存的结果为 `driver.Rows`，需要转换成 `*sql.Rows` 方便后续使用，&#13;
因此想到通过 `sqlmock` 的方式，但是默认的 `value converter` 是 `driver.DefaultParameterConverter`，只能转换基础类型，&#13;
复杂类型也没有定义专门用于解析的结构体，会报诸如以下的错误，&#13;
&#13;
&gt; panic: row #1, column #2 ('mapper') type map[string]uint8: unsupported type map[string]uint8, a map&#13;
&#13;
好在 `go-sqlmock` 可以指定 `ValueConverterOption`，这样就可以把 `driver.Rows` 转换成 `*sql.Rows` 了。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-ru-he-shi-xian-%20Clickhouse%20-cha-xun-huan-cun.html</guid><pubDate>Sun, 09 Jun 2024 06:43:22 +0000</pubDate></item><item><title>Go 有趣的代码片段</title><link>https://night1008.github.io/post/Go%20-you-qu-de-dai-ma-pian-duan.html</link><description>### 可以对 error 进行 switch 判断&#13;
&#13;
来源：https://github.com/prashanthpai/sqlcache/blob/4bf943bfd00f02394a480c5437e86af4b5be074c/cache_redis.go#L24&#13;
&#13;
```go&#13;
func (r *Redis) Get(ctx context.Context, key string) (*cache.Item, bool, error) {&#13;
	b, err := r.c.Get(ctx, r.keyPrefix+key).Bytes()&#13;
	switch err {&#13;
	case nil:&#13;
		var item cache.Item&#13;
		if err := msgpack.Unmarshal(b, &amp;item); err != nil {&#13;
			return nil, true, err&#13;
		}&#13;
		return &amp;item, true, nil&#13;
	case redis.Nil:&#13;
		return nil, false, nil&#13;
	default:&#13;
		return nil, false, err&#13;
	}&#13;
}&#13;
```&#13;
&#13;
---&#13;
&#13;
### 匿名结构体&#13;
&#13;
来源：https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/concurrency#channels&#13;
&#13;
```go&#13;
type result struct {&#13;
	string&#13;
	bool&#13;
}&#13;
&#13;
var r result&#13;
fmt.Println(r.string, r.bool)&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-you-qu-de-dai-ma-pian-duan.html</guid><pubDate>Sat, 01 Jun 2024 13:01:05 +0000</pubDate></item><item><title>分析平台中的业务关系图</title><link>https://night1008.github.io/post/fen-xi-ping-tai-zhong-de-ye-wu-guan-xi-tu.html</link><description>### 用户和应用角色之间的关系&#13;
![user_role_permission](https://github.com/night1008/night1008.github.io/assets/3940006/214e5136-2ac8-453f-8ddb-e4cd865e4027)&#13;
&#13;
---&#13;
&#13;
### 表和属性之间的关系&#13;
![event_property](https://github.com/night1008/night1008.github.io/assets/3940006/33933ff6-4c26-434b-a190-3ed98f2b5bc9)&#13;
&#13;
&#13;
---&#13;
&#13;
### 看板空间和看板之间的关系&#13;
![dashboard_space](https://github.com/night1008/night1008.github.io/assets/3940006/40200478-f311-40a1-ba05-1e3e0a80a394)&#13;
。</description><guid isPermaLink="true">https://night1008.github.io/post/fen-xi-ping-tai-zhong-de-ye-wu-guan-xi-tu.html</guid><pubDate>Thu, 25 Apr 2024 09:17:32 +0000</pubDate></item><item><title>如何在 iOS 上安装 PokeMMO</title><link>https://night1008.github.io/post/ru-he-zai-%20iOS%20-shang-an-zhuang-%20PokeMMO.html</link><description>准备条件：&#13;
1.  [PokeMMO Account](https://pokemmo.com/en/)&#13;
2. [AltStore](https://iosdroids.com/altstore/)&#13;
3. [PokeMMO ROMS](https://iosdroids.com/pokemmo-ios/)&#13;
&#13;
找了好久总算在 [How to Download &amp; Install PokeMMO on iOS?](https://iosdroids.com/pokemmo-ios/) 找到可下载的 PokeMMO ROMS.&#13;
。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-zai-%20iOS%20-shang-an-zhuang-%20PokeMMO.html</guid><pubDate>Sun, 14 Apr 2024 14:55:47 +0000</pubDate></item><item><title>clickhouse-go 某些查询不会返回查询错误</title><link>https://night1008.github.io/post/clickhouse-go%20-mou-xie-cha-xun-bu-hui-fan-hui-cha-xun-cuo-wu.html</link><description>使用 [clickhouse-go](https://github.com/ClickHouse/clickhouse-go) 作为客户端进行 clickhouse 查询时，发现某些查询不会返回查询错误，&#13;
1. 查询时间超过最大查询时间参数 (max_execution_time)&#13;
2. 非法查询，比如 sleep(300)&#13;
&#13;
下面给示例，&#13;
&#13;
```go&#13;
package main&#13;
&#13;
import (&#13;
	'context'&#13;
	'fmt'&#13;
	'log'&#13;
&#13;
	'github.com/ClickHouse/clickhouse-go/v2'&#13;
)&#13;
&#13;
func main() {&#13;
	db := clickhouse.OpenDB(&amp;clickhouse.Options{&#13;
		Addr: []string{'127.0.0.1:9000'},&#13;
		Auth: clickhouse.Auth{&#13;
			Database: 'default',&#13;
			Username: 'default',&#13;
			Password: '',&#13;
		},&#13;
		Settings: clickhouse.Settings{&#13;
			'join_use_nulls': 1,&#13;
		},&#13;
	})&#13;
&#13;
	ctx := context.Background()&#13;
	conn, err := db.Conn(ctx)&#13;
	if err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
	defer conn.Close()&#13;
&#13;
	sql := 'select sleep(300)'&#13;
	rows, err := conn.QueryContext(ctx, sql)&#13;
	if err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
	defer rows.Close()&#13;
&#13;
	fmt.Println(rows.Columns())&#13;
}&#13;
```&#13;
&#13;
期望结果是，&#13;
```&#13;
code: 160, message: The maximum sleep time is 3000000 microseconds. Requested: 300: while executing 'FUNCTION sleep(300 :: 0) -&gt; sleep(300) UInt8 : 1'&#13;
```&#13;
&#13;
执行结果是，&#13;
```&#13;
[sleep(300)] &lt;nil&gt;&#13;
```&#13;
&#13;
---&#13;
&#13;
问了官方，说是，&#13;
Since the error is not thrown in ClickHouse at the time of query retrieval but later with the data packet, the client has to process data received from the server explicitly using rows.Next().&#13;
&#13;
See code snippet:&#13;
```go&#13;
package issues&#13;
&#13;
import (&#13;
	'context'&#13;
	'testing'&#13;
&#13;
	clickhouse_tests 'github.com/ClickHouse/clickhouse-go/v2/tests'&#13;
	'github.com/stretchr/testify/assert'&#13;
	'github.com/stretchr/testify/require'&#13;
)&#13;
&#13;
func Test1268(t *testing.T) {&#13;
	conn, err := clickhouse_tests.GetDatabaseSQLConnection('issues', nil, nil, nil)&#13;
	require.NoError(t, err)&#13;
&#13;
	rows, err := conn.QueryContext(context.Background(), 'select sleep(300)')&#13;
	require.NoError(t, err)&#13;
	defer rows.Close()&#13;
&#13;
	for rows.Next() {&#13;
		if rows.Err() != nil {&#13;
			break&#13;
		}&#13;
	}&#13;
&#13;
	assert.ErrorContains(t, rows.Err(), 'code: 160, message: The maximum sleep time is 3000000 microseconds.')&#13;
}&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/clickhouse-go%20-mou-xie-cha-xun-bu-hui-fan-hui-cha-xun-cuo-wu.html</guid><pubDate>Sun, 14 Apr 2024 04:00:07 +0000</pubDate></item><item><title>Go 语言下如何提交包含反引号的多行字符串表单</title><link>https://night1008.github.io/post/Go%20-yu-yan-xia-ru-he-ti-jiao-bao-han-fan-yin-hao-de-duo-xing-zi-fu-chuan-biao-dan.html</link><description>感觉 Go 语言对于多行字符串的支持不是很友好。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-yu-yan-xia-ru-he-ti-jiao-bao-han-fan-yin-hao-de-duo-xing-zi-fu-chuan-biao-dan.html</guid><pubDate>Sun, 14 Apr 2024 03:57:34 +0000</pubDate></item><item><title>如何实现超管登录</title><link>https://night1008.github.io/post/ru-he-shi-xian-chao-guan-deng-lu.html</link><description>对于 ToC 平台，随着接入应用的增加，用户反馈的问题也变多，&#13;
日志没有记录到的话，加上现有的权限体系下查看问题不方便，&#13;
很难复现问题，需要一个个加到对应的应用中。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-shi-xian-chao-guan-deng-lu.html</guid><pubDate>Thu, 15 Feb 2024 04:40:48 +0000</pubDate></item><item><title>如何进行前后端静态资源分离</title><link>https://night1008.github.io/post/ru-he-jin-xing-qian-hou-duan-jing-tai-zi-yuan-fen-li.html</link><description>我目前开发的平台的前端静态资源是使用 [go embed](https://pkg.go.dev/embed) 机制内嵌到后端服务中，&#13;
当访问量比较大的时候，服务器会有比较大的 IO 消耗，因此进行前端静态资源分离。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-jin-xing-qian-hou-duan-jing-tai-zi-yuan-fen-li.html</guid><pubDate>Wed, 14 Feb 2024 04:40:48 +0000</pubDate></item></channel></rss>