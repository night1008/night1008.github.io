<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Night1008</title><link>https://night1008.github.io</link><description>静以修身，俭以养德</description><copyright>Night1008</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://night1008.github.io</link></image><lastBuildDate>Wed, 09 Apr 2025 01:51:02 +0000</lastBuildDate><managingEditor>Night1008</managingEditor><ttl>60</ttl><webMaster>Night1008</webMaster><item><title>Golang gorm 实现任意层级的文件夹模型</title><link>https://night1008.github.io/post/Golang%20gorm%20-shi-xian-ren-yi-ceng-ji-de-wen-jian-jia-mo-xing.html</link><description>记录一下如何使用 gorm 实现任意层级的文件夹模型，代码如下


```go
type AdFolder struct {
	ID        uint64 `gorm:'primarykey'`           // 数据库ID
	CreatedAt int64  `gorm:'autoCreateTime:milli'` // 记录创建时间，单位 milli
	UpdatedAt int64  `gorm:'autoUpdateTime:milli'` // 记录更新时间，单位 milli

	AppID       uint64 `gorm:'index:idx_ad_folders_type'` // 应用ID
	Type        string `gorm:'index:idx_ad_folders_type'` // 分类类型
	Title       string // 标题
	Description string // 说明
	ParentID    uint64 `gorm:'index'` // 父文件夹ID
	RootID      uint64 `gorm:'index'` // 根文件夹ID

	CreatorID    uint64 // 创建用户ID
	LastEditorID uint64 // 最后编辑用户ID

	Parent      *AdFolder   `gorm:'foreignKey:ParentID'` // 父节点
	Children    []*AdFolder `gorm:'foreignKey:ParentID'` // 直系子节点
	Root        *AdFolder   `gorm:'foreignKey:RootID'`   // 根节点
	Descendants []*AdFolder `gorm:'foreignKey:RootID'`   // 根系子节点
}


// 获取根文件夹ID
func (a *AdFolder) GetFolderRootID() uint64 {
	var rootID uint64
	if a.RootID != 0 {
		rootID = a.RootID
	} else if a.ID != 0 {
		rootID = a.ID
	}
	return rootID
}

// 获取相同根节点的文件夹列表
func (a *AdFolder) GetSameRootAdFolders(tx *gorm.DB) ([]*AdFolder, error) {
	var adFolders []*AdFolder
	query := tx.Model(&amp;AdFolder{}).
		Where('app_id = ?', a.AppID).
		Where('type = ?', a.Type)
	if a.RootID == 0 {
		query = query.Where('(id = ? OR root_id = ?)', a.ID, a.ID)
	} else {
		query = query.Where('(id = ? OR root_id = ?)', a.RootID, a.RootID)
	}
	if err := query.Order('id DESC').
		Find(&amp;adFolders).Error; err != nil {
		return nil, err
	}
	return adFolders, nil
}

// 构造文件夹父节点数组
func (a *AdFolder) GetAdFolderParents(tx *gorm.DB) ([]*AdFolder, error) {
	adFolders, err := a.GetSameRootAdFolders(tx)
	if err != nil {
		return nil, err
	}
	adFoldersMap := make(map[uint64]*AdFolder, len(adFolders))
	parentAdFoldersMap := make(map[uint64]uint64, len(adFolders)) // children : parent
	for _, folder := range adFolders {
		adFoldersMap[folder.ID] = folder
		if folder.ParentID != 0 {
			parentAdFoldersMap[folder.ID] = folder.ParentID
		}
	}

	var parents []*AdFolder
	currentID := a.ID
	for {
		parentID, exists := parentAdFoldersMap[currentID]
		if !exists {
			break
		}

		parent, ok := adFoldersMap[parentID]
		if !ok {
			break
		}

		parents = append([]*AdFolder{parent}, parents...)
		currentID = parentID
	}
	return parents, nil
}

// 构造文件夹树形结构
func BuildAdFolderTree(adFolders []*AdFolder) []*AdFolder {
	adFoldersMap := make(map[uint64]*AdFolder, len(adFolders))
	for _, adFolder := range adFolders {
		adFoldersMap[adFolder.ID] = adFolder
	}

	var roots []*AdFolder
	for _, adFolder := range adFolders {
		if adFolder.ParentID == 0 {
			roots = append(roots, adFolder)
		} else {
			if parent, ok := adFoldersMap[adFolder.ParentID]; ok {
				parent.Children = append(parent.Children, adFolder)
				adFoldersMap[adFolder.ParentID] = parent
			}
		}
	}
	return roots
}

// 寻找所有后代节点
func (a *AdFolder) GetAdFolderDescendants(tx *gorm.DB) ([]*AdFolder, error) {
	adFolders, err := a.GetSameRootAdFolders(tx)
	if err != nil {
		return nil, err
	}
	adFoldersMap := make(map[uint64]*AdFolder)
	childrenMap := make(map[uint64][]uint64)

	for _, adFolder := range adFolders {
		adFoldersMap[adFolder.ID] = adFolder
		if adFolder.ParentID != 0 {
			childrenMap[adFolder.ParentID] = append(childrenMap[adFolder.ParentID], adFolder.ID)
		}
	}

	var children []*AdFolder
	queue := []uint64{a.ID}
	for len(queue) &gt; 0 {
		currentID := queue[0]
		queue = queue[1:]
		for _, childID := range childrenMap[currentID] {
			if child, exists := adFoldersMap[childID]; exists {
				children = append(children, child)
				queue = append(queue, childID)
			}
		}
	}
	return children, nil
}
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Golang%20gorm%20-shi-xian-ren-yi-ceng-ji-de-wen-jian-jia-mo-xing.html</guid><pubDate>Tue, 08 Apr 2025 10:19:54 +0000</pubDate></item><item><title>Golang json.Marshal 序列化转义问题</title><link>https://night1008.github.io/post/Golang%20json.Marshal%20-xu-lie-hua-zhuan-yi-wen-ti.html</link><description>Golang 对包含链接地址的数据进行序列化后发现地址不能直接使用了，测试代码如下。</description><guid isPermaLink="true">https://night1008.github.io/post/Golang%20json.Marshal%20-xu-lie-hua-zhuan-yi-wen-ti.html</guid><pubDate>Thu, 20 Mar 2025 08:27:22 +0000</pubDate></item><item><title>Golang MySQL 通过 interface{} 解析查询结果的内容为 []byte</title><link>https://night1008.github.io/post/Golang%20MySQL%20-tong-guo-%20interface%7B%7D%20-jie-xi-cha-xun-jie-guo-de-nei-rong-wei-%20%5B%5Dbyte.html</link><description>发现 Golang MySQL 下，MySQL 驱动默认把 interface{} 类型解析为 []byte，导致字符串和数字以 Base64 编码形式返回。</description><guid isPermaLink="true">https://night1008.github.io/post/Golang%20MySQL%20-tong-guo-%20interface%7B%7D%20-jie-xi-cha-xun-jie-guo-de-nei-rong-wei-%20%5B%5Dbyte.html</guid><pubDate>Mon, 10 Mar 2025 09:20:24 +0000</pubDate></item><item><title>不同广告渠道报表类型级别的对应关系</title><link>https://night1008.github.io/post/bu-tong-guang-gao-qu-dao-bao-biao-lei-xing-ji-bie-de-dui-ying-guan-xi.html</link><description>不同广告渠道报表类型级别的对应关系

|    | 腾讯广告 | 巨量广告 |
| -------- | ------- | ------- |
| 广告主帐号  | 账号ID(account_id)    | 广告主id(advertiser_id)   |
| 广告计划 | 广告组ID(adgroup_id)   | 项目ID(cdp_project_id)   |
| 广告创意    | 动态创意id(dynamic_creative_id)   | 广告ID(cdp_promotion_id)    |

参考链接
- [腾讯广告 - 获取日报表](https://developers.e.qq.com/v3.0/docs/api/daily_reports/get)
- [巨量广告 - 获取自定义报表可用指标和维度](https://open.oceanengine.com/labels/7/docs/1755261744248832)
- [巨量广告 - 自定义报表](https://open.oceanengine.com/labels/7/docs/1741387668314126)。</description><guid isPermaLink="true">https://night1008.github.io/post/bu-tong-guang-gao-qu-dao-bao-biao-lei-xing-ji-bie-de-dui-ying-guan-xi.html</guid><pubDate>Thu, 06 Mar 2025 03:18:06 +0000</pubDate></item><item><title>Clickhouse 如何实现间隔分析</title><link>https://night1008.github.io/post/Clickhouse%20-ru-he-shi-xian-jian-ge-fen-xi.html</link><description>通过间隔分析查看转化时长的分布情况。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20-ru-he-shi-xian-jian-ge-fen-xi.html</guid><pubDate>Fri, 28 Feb 2025 07:55:12 +0000</pubDate></item><item><title>Clickhouse arrayJoin 数组字段无值被过滤问题</title><link>https://night1008.github.io/post/Clickhouse%20arrayJoin%20-shu-zu-zi-duan-wu-zhi-bei-guo-lv-wen-ti.html</link><description>Clickhouse 使用 arrayJoin 展开数组字段时，有些数组字段可能是没有值的，这时候这些记录会被过滤掉，如下所示，

```sql
select *, arrayJoin(a) as b_item from (
  select array(1, 2, 3) as a, 1 as b
  union all
  select array(1) as a, 2 as b
  union all
  select array() as a, 3 as b
)

   ┌─a───────┬─b─┬─b_item─┐
1. │ [1,2,3] │ 1 │      1 │
2. │ [1,2,3] │ 1 │      2 │
3. │ [1,2,3] │ 1 │      3 │
   └─────────┴───┴────────┘
   ┌─a───┬─b─┬─b_item─┐
4. │ [1] │ 2 │      1 │
   └─────┴───┴────────┘
```

---

解决方法如下

```sql
select *, arrayJoin(if(empty(a), [null], a)) as b_item from (
  select array(1, 2, 3) as a, 1 as b
  union all
  select array(1) as a, 2 as b
  union all
  select array() as a, 3 as b
)

   ┌─a───┬─b─┬─b_item─┐
1. │ [1] │ 2 │      1 │
   └─────┴───┴────────┘
   ┌─a───────┬─b─┬─b_item─┐
2. │ [1,2,3] │ 1 │      1 │
3. │ [1,2,3] │ 1 │      2 │
4. │ [1,2,3] │ 1 │      3 │
   └─────────┴───┴────────┘
   ┌─a──┬─b─┬─b_item─┐
5. │ [] │ 3 │   ᴺᵁᴸᴸ │
   └────┴───┴────────┘
```

```sql
select *, arrayJoin(range(1, length(if(empty(a), [null], a)) + 1)) AS b_item_index from (
  select array(1, 2, 3) as a, 1 as b
  union all
  select array(1) as a, 2 as b
  union all
  select array() as a, 3 as b
)

   ┌─a───┬─b─┬─b_item_index─┐
1. │ [1] │ 2 │            1 │
   └─────┴───┴──────────────┘
   ┌─a──┬─b─┬─b_item_index─┐
2. │ [] │ 3 │            1 │
   └────┴───┴──────────────┘
   ┌─a───────┬─b─┬─b_item_index─┐
3. │ [1,2,3] │ 1 │            1 │
4. │ [1,2,3] │ 1 │            2 │
5. │ [1,2,3] │ 1 │            3 │
   └─────────┴───┴──────────────┘
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20arrayJoin%20-shu-zu-zi-duan-wu-zhi-bei-guo-lv-wen-ti.html</guid><pubDate>Thu, 27 Feb 2025 03:52:03 +0000</pubDate></item><item><title>使用 PostgreSQL + PostgREST 加快后端开发</title><link>https://night1008.github.io/post/shi-yong-%20PostgreSQL%20%2B%20PostgREST%20-jia-kuai-hou-duan-kai-fa.html</link><description>使用 PostgreSQL + PostgREST，可以省去大部分后端编写工作。</description><guid isPermaLink="true">https://night1008.github.io/post/shi-yong-%20PostgreSQL%20%2B%20PostgREST%20-jia-kuai-hou-duan-kai-fa.html</guid><pubDate>Sun, 23 Feb 2025 03:28:02 +0000</pubDate></item><item><title>Visual Studio Code 插件列表</title><link>https://night1008.github.io/post/Visual%20Studio%20Code%20-cha-jian-lie-biao.html</link><description>1. [Git Stash](https://marketplace.visualstudio.com/items?itemName=arturock.gitstash)。</description><guid isPermaLink="true">https://night1008.github.io/post/Visual%20Studio%20Code%20-cha-jian-lie-biao.html</guid><pubDate>Sat, 25 Jan 2025 04:41:05 +0000</pubDate></item><item><title>通用业务使用手册</title><link>https://night1008.github.io/post/tong-yong-ye-wu-shi-yong-shou-ce.html</link><description>### 数据库表标识字段生成规则

正常数据库记录有自增的数字ID，另外有些记录还需要生成英文标识字段

比如现在`应用`表要增加一个`标识`字段，
不要使用中文转拼音的方式，比如 `数据测试` =&gt; `shu_ju_ce_shi_d4qbfwuf`
可以使用 **固定长度的唯一字符串**，比如 `app_t07o2yt58p`

优点：后续改名称可以不用去管标识字段内容

---

### 业务关键步骤打印日志

比如以任务执行为例，在任务开始，任务阶段1，任务阶段2，... 任务阶段N，任务结束都可以打印一些关键信息

优点：方便查看执行情况和后续定位问题

---

### 数据库字段名称命名规则

1. 小写字母 + 下划线
&gt; 字段名称中只能包含字母、数字和下划线 _
&gt; 比如 user_id, created_at, first_name
&gt; 不使用驼峰命名法，因为某些数据库（如 PostgreSQL）默认将字段名称转换为小写，可能导致问题

2. 使用前缀来区分字段类型或用途
&gt; 使用 is_ 或 has_ 前缀表示布尔值，比如，is_active：是否激活；has_permission：是否有权限
&gt; 比如为了区分系统预置和用户自定义，可以对预置属性增加 pre_ 的前缀

3. 避免特殊字符
&gt; 尽量不要使用如 #, $, _ 的前缀，以免出现通过字段名称构建路径的问题。</description><guid isPermaLink="true">https://night1008.github.io/post/tong-yong-ye-wu-shi-yong-shou-ce.html</guid><pubDate>Thu, 16 Jan 2025 07:35:10 +0000</pubDate></item><item><title>Clickhouse 业务使用手册</title><link>https://night1008.github.io/post/Clickhouse%20-ye-wu-shi-yong-shou-ce.html</link><description>### 时间戳转时间
```sql
select `#time`, timestamp_add(fromUnixTimestamp64Milli(`#time`), interval coalesce(`#zone_offset`, 8) * 60 minute) from events where `#event` = '#device_login' and `#dt` = '2025-03-01' limit 100;
```
---

### 变更语句是否执行完
```sql
select hostname(),* from clusterAllReplicas('default','system.mutations') where is_done = 0;
```
---

### 清理数据库表
```sql
truncate table demo.events_local;
truncate table demo_global.users_local;
truncate table demo_global.devices_local;
```
---

### 根据 query 查询 clickhouse 日志
```sql
select * from cluster('all-sharded', 'system', 'query_log') where query_id  = '4efbbb9b-b853-44ca-84b2-95ff066895af';
```
---

### 数据导出成CSV
```sql
SELECT * FROM events
SETTINGS join_use_nulls=1, allow_experimental_analyzer=0
INTO OUTFILE '新玩家首日首场战场数据.csv.gz'
FORMAT CSVWithNames;
```
---

### 数据去重验证
```sql
select `_part`, `#dt`, `#event`, `#log_id`, count(1), groupArray(hostname()) from events where `#dt` = '2024-07-28' group by 1, 2, 3, 4 order by 5 desc limit 100;
```
。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20-ye-wu-shi-yong-shou-ce.html</guid><pubDate>Mon, 13 Jan 2025 06:43:46 +0000</pubDate></item><item><title>分布分析中如何划分区间</title><link>https://night1008.github.io/post/fen-bu-fen-xi-zhong-ru-he-hua-fen-qu-jian.html</link><description>### 问题&#13;
分布分析中需要根据某一步长对一组值进行区间划分，且其包含正负数。</description><guid isPermaLink="true">https://night1008.github.io/post/fen-bu-fen-xi-zhong-ru-he-hua-fen-qu-jian.html</guid><pubDate>Fri, 10 Jan 2025 06:30:43 +0000</pubDate></item><item><title>Clickhouse Golang 从缓存中读取时间类型字段丢失时区的问题</title><link>https://night1008.github.io/post/Clickhouse%20Golang%20-cong-huan-cun-zhong-du-qu-shi-jian-lei-xing-zi-duan-diu-shi-shi-qu-de-wen-ti.html</link><description>### 背景&#13;
&#13;
使用以下两个包进行 clickhouse 查询数据缓存，发现命中缓存时，返回的时间类型字段的值偏移了八个小时，服务器时区是零时区&#13;
- https://github.com/ClickHouse/clickhouse-go&#13;
- https://github.com/night1008/sqlcache&#13;
&#13;
### 问题原因&#13;
直接通过数据库查询的时间是东八区，比如 `2024-12-05 00:00:05.657 +0800 CST`，&#13;
但是后面命中缓存从中拿到的时区是零时区(服务器时区是零时区)，比如 `2024-12-04 16:00:05.657 +0000 UTC`，&#13;
这样再对时间字段做格式化的时候就会差了八个时区，&#13;
不过这时候缓存已丢失了最开始查询所携带的时区&#13;
&#13;
### 解决方法&#13;
1. 缓存查询数据的同时，缓存列的信息，来自 sql.DatabaseTypeName()，比如 DateTime64(3, 'Asia/Shanghai')&#13;
2. 查询命中缓存时通过解析列信息列得到时区&#13;
3. 对时间字段指定解析后的时区进行格式化&#13;
&#13;
不过本质原因是缓存包使用 `msgpack` 进行序列化，该方式没有保存时区信息，  &#13;
因此还可以有其他的解决方法，&#13;
1. 寻找`msgpack` 关于时间类型的扩展&#13;
2. 实现新的缓存包的接口，使用其他序列化方式，比如 `json`&#13;
&#13;
---&#13;
&#13;
发现一个有意思的现象，通过 `union` 的方式查询两条不同时区的数据，后续的数据都会转换成第一条数据所拥有的时区。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20Golang%20-cong-huan-cun-zhong-du-qu-shi-jian-lei-xing-zi-duan-diu-shi-shi-qu-de-wen-ti.html</guid><pubDate>Mon, 06 Jan 2025 07:09:51 +0000</pubDate></item><item><title>Go 全局时区设置</title><link>https://night1008.github.io/post/Go%20-quan-ju-shi-qu-she-zhi.html</link><description>正常本地开发环境的时区是东八区，线上服务器的时区是零时区，  &#13;
调试一些线上服务器的时区问题的时候，如何通过设置全局时区在本地进行调试呢。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-quan-ju-shi-qu-she-zhi.html</guid><pubDate>Mon, 06 Jan 2025 02:08:02 +0000</pubDate></item><item><title>PostgreSQL 业务使用手册</title><link>https://night1008.github.io/post/PostgreSQL%20-ye-wu-shi-yong-shou-ce.html</link><description>### 手动修改联合主键表索引

原本 `ad_advertisers` 表以 `app_id`, `channel_name`, `account_id` 三个字段为主键，现在如何往中间再加一个主键字段

```sql
CREATE UNIQUE INDEX ad_advertisers_pkey ON public.ad_advertisers USING btree (app_id, channel_name, account_id);

=&gt;

ALTER TABLE public.ad_advertisers DROP CONSTRAINT ad_advertisers_pkey;
UPDATE ad_advertisers SET account_type = '' WHERE account_type IS NULL;
ALTER TABLE public.ad_advertisers ADD CONSTRAINT ad_advertisers_pkey PRIMARY KEY (app_id, channel_name, account_type, account_id);
```

---

### 重置数据库表 ID

```sql
ALTER SEQUENCE users_id_seq RESTART WITH 7;
```

---

### 查看表结构

```sql
pg_dump -h localhost -p 5432 -U postgres -d db_name -t table_name --schema-only
```

---

### 表大小情况查询

```sql
-- 查看每个表的占用空间大小
select
  table_name, 
  pg_size_pretty(pg_total_relation_size(quote_ident(table_name))),
  pg_relation_size(quote_ident(table_name))
from information_schema.tables
where table_schema = 'public'
order by 3 desc;

-- 查看每个表的行数
SELECT 
    schemaname AS schema,
    relname AS table,
    n_live_tup AS estimated_row_count
FROM 
    pg_stat_user_tables
ORDER BY 3 desc;

-- 查看某个数据库磁盘占用情况
select pg_size_pretty(pg_database_size('funnydb_web'));

-- 查看全部数据库磁盘占用情况
SELECT datname as db_name, pg_size_pretty(pg_database_size(datname)) as db_usage FROM pg_database order by db_usage desc;
```

---

### 查询列的字段类型
```sql
select pg_typeof('column1'), pg_typeof('column2') from table1;
```

---

### 文本类型字段的数字匹配
```sql
SELECT value, value::numeric FROM property_values where value ~ '^[-0-9.]+$' limit 1000;

select min(id) from (select '10005' as id union all select '995' as id);  -- 错误写法
```

---

### 复制表
```sql
create table users_old as (select * from users);
```
。</description><guid isPermaLink="true">https://night1008.github.io/post/PostgreSQL%20-ye-wu-shi-yong-shou-ce.html</guid><pubDate>Thu, 26 Dec 2024 06:22:19 +0000</pubDate></item><item><title>分布式任务调度设计要点</title><link>https://night1008.github.io/post/fen-bu-shi-ren-wu-diao-du-she-ji-yao-dian.html</link><description>设计要点：&#13;
1. 任务函数注册方便，参考 http 函数注册&#13;
2. 任务创建可以指定参数，比如重试次数，延迟执行，超时时间等&#13;
3. 任务可以分队列，避免阻塞，比如高中低优先级&#13;
4. 任务执行 worker 数量可以任意扩展&#13;
5. 支持指定定时任务，定时任务的产生可以通过数据库生成，这样方便修改任务信息&#13;
6. 相同定时任务可以指定不同定时时间，不同时区&#13;
&#13;
因为业务上有定时任务的场景，之前思考如何使用 redis 达到上面的设计要点时，一直没想通怎么做，  &#13;
直到看到 https://github.com/hibiken/asynq 的实现，没想到可以通过外部定时器发送定时任务的方式达到效果。</description><guid isPermaLink="true">https://night1008.github.io/post/fen-bu-shi-ren-wu-diao-du-she-ji-yao-dian.html</guid><pubDate>Thu, 19 Dec 2024 06:48:23 +0000</pubDate></item><item><title>Go Gorm 如何查询动态字段列表且能更新查询后的结果数据</title><link>https://night1008.github.io/post/Go%20Gorm%20-ru-he-cha-xun-dong-tai-zi-duan-lie-biao-qie-neng-geng-xin-cha-xun-hou-de-jie-guo-shu-ju.html</link><description>### 背景&#13;
&#13;
最近广告业务上的一些报表查询接口，需要根据前端指定的字段列表返回查询聚合结果，其中某些字段不方便在数据库中直接查询得到，需要经过服务端二次计算，才能得到最终结果。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20Gorm%20-ru-he-cha-xun-dong-tai-zi-duan-lie-biao-qie-neng-geng-xin-cha-xun-hou-de-jie-guo-shu-ju.html</guid><pubDate>Fri, 29 Nov 2024 03:30:08 +0000</pubDate></item><item><title>Go web application packages</title><link>https://night1008.github.io/post/Go%20web%20application%20packages.html</link><description>1. [github.com/gin-gonic/gin](https://github.com/gin-gonic/gin) (framework)&#13;
2. [github.com/spf13/cobra](https://github.com/spf13/cobra) (cli)&#13;
3. [github.com/spf13/viper](https://github.com/spf13/viper) (config)&#13;
4. [gorm.io/gorm](https://gorm.io/gorm) (orm)&#13;
5. [github.com/rs/zerolog](https://github.com/rs/zerolog) (log)。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20web%20application%20packages.html</guid><pubDate>Wed, 13 Nov 2024 05:54:43 +0000</pubDate></item><item><title>关于 Golang viper mapstructure 反序列化多次数组类型输出错误</title><link>https://night1008.github.io/post/guan-yu-%20Golang%20viper%20mapstructure%20-fan-xu-lie-hua-duo-ci-shu-zu-lei-xing-shu-chu-cuo-wu.html</link><description>业务程序使用了 Golang 中的 [viper](github.com/spf13/viper) 进行加载配置，&#13;
但在实际使用过程中因为读取了两次配置，同时反序列化了两次，&#13;
导致一些数组类型的字段出现了不符合预期的结果，如下测试程序所示。</description><guid isPermaLink="true">https://night1008.github.io/post/guan-yu-%20Golang%20viper%20mapstructure%20-fan-xu-lie-hua-duo-ci-shu-zu-lei-xing-shu-chu-cuo-wu.html</guid><pubDate>Fri, 01 Nov 2024 02:56:12 +0000</pubDate></item><item><title>PostgreSQL 持有行级别锁后表字段变更失败的问题</title><link>https://night1008.github.io/post/PostgreSQL%20-chi-you-xing-ji-bie-suo-hou-biao-zi-duan-bian-geng-shi-bai-de-wen-ti.html</link><description>### 背景&#13;
&#13;
我们使用了 `PostgreSQL` 表的记录作为任务只在单个节点上执行的全局锁，&#13;
并且使用的是 `FOR UPDATE` 的行级别锁，&#13;
但在锁已被表持有的情况下，如果要对表结构进行变更字段的话，会执行失败，&#13;
场景为旧部署服务已持有了行级别锁，新部署服务就变更不了表结构，&#13;
因为 DDL 操作（如添加列）会对整个表加锁，这两者发生了冲突。</description><guid isPermaLink="true">https://night1008.github.io/post/PostgreSQL%20-chi-you-xing-ji-bie-suo-hou-biao-zi-duan-bian-geng-shi-bai-de-wen-ti.html</guid><pubDate>Thu, 10 Oct 2024 09:59:24 +0000</pubDate></item><item><title>Clickhouse 如何实现 LTV 分析</title><link>https://night1008.github.io/post/Clickhouse%20-ru-he-shi-xian-%20LTV%20-fen-xi.html</link><description>### 背景&#13;
&#13;
LTV 是 Life Time Value 缩写，即用户在生命周期中贡献的商业价值。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20-ru-he-shi-xian-%20LTV%20-fen-xi.html</guid><pubDate>Wed, 09 Oct 2024 02:41:30 +0000</pubDate></item><item><title>如何通过数据库全局锁方式实现任务单节点执行</title><link>https://night1008.github.io/post/ru-he-tong-guo-shu-ju-ku-quan-ju-suo-fang-shi-shi-xian-ren-wu-dan-jie-dian-zhi-xing.html</link><description>通过 `postgres` 的数据库行级别的锁机制全局控制所有的任务只在某个节点上执行&#13;
&#13;
```go&#13;
package main&#13;
&#13;
import (&#13;
	'context'&#13;
	'errors'&#13;
	'log'&#13;
	'time'&#13;
&#13;
	'github.com/jackc/pgconn'&#13;
	'golang.org/x/sync/errgroup'&#13;
	'gorm.io/driver/postgres'&#13;
	'gorm.io/gorm'&#13;
	'gorm.io/gorm/clause'&#13;
	'gorm.io/gorm/logger'&#13;
)&#13;
&#13;
const (&#13;
	globalJobLockGetPollingDuration = time.Second // 全局任务锁轮询时间&#13;
&#13;
	ServiceDeploymentNameGlobalJobLock = 'global-job-lock' // 全局任务锁&#13;
)&#13;
&#13;
type ServiceDeployment struct {&#13;
	Name string `gorm:'primarykey'` // 服务名称&#13;
&#13;
	CreatedAt int64 `gorm:'autoCreateTime:milli'` // 记录创建时间，单位 milli&#13;
	UpdatedAt int64 `gorm:'autoUpdateTime:milli'` // 记录更新时间，单位 milli&#13;
}&#13;
&#13;
func main() {&#13;
	dsn := 'host=localhost user=postgres password=secret dbname=test port=5432 sslmode=disable'&#13;
	db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})&#13;
	if err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
	if err := db.AutoMigrate(&amp;ServiceDeployment{}); err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
&#13;
	var jobEnable bool&#13;
&#13;
	eg, ctx := errgroup.WithContext(context.Background())&#13;
	eg.Go(func() error {&#13;
		ticker := time.NewTicker(globalJobLockGetPollingDuration)&#13;
		defer ticker.Stop()&#13;
&#13;
		for {&#13;
			exist, err := GetGlobalJobLock(db)&#13;
			if err != nil {&#13;
				log.Println(err)&#13;
			}&#13;
			if exist {&#13;
				jobEnable = true&#13;
				break&#13;
			}&#13;
&#13;
			select {&#13;
			case &lt;-ctx.Done():&#13;
				return ctx.Err()&#13;
			case &lt;-ticker.C:&#13;
			}&#13;
		}&#13;
		return nil&#13;
	})&#13;
&#13;
	eg.Go(func() error {&#13;
		if err := stopTickerUntil(ctx, globalJobLockGetPollingDuration, func() bool {&#13;
			return jobEnable&#13;
		}); err != nil {&#13;
			return err&#13;
		}&#13;
		return RunJob(ctx)&#13;
	})&#13;
&#13;
	if err := eg.Wait(); err != nil {&#13;
		log.Println(err)&#13;
	}&#13;
}&#13;
&#13;
func FindOne(db *gorm.DB, out interface{}) (bool, error) {&#13;
	result := db.First(out)&#13;
	if err := result.Error; err != nil {&#13;
		if errors.Is(err, gorm.ErrRecordNotFound) {&#13;
			return false, nil&#13;
		}&#13;
		return false, err&#13;
	}&#13;
	return true, nil&#13;
}&#13;
&#13;
func GetGlobalJobLock(db *gorm.DB) (bool, error) {&#13;
	deployment := ServiceDeployment{&#13;
		Name: ServiceDeploymentNameGlobalJobLock,&#13;
	}&#13;
	if err := db.FirstOrCreate(&amp;deployment, ServiceDeployment{Name: ServiceDeploymentNameGlobalJobLock}).Error; err != nil {&#13;
		return false, err&#13;
	}&#13;
&#13;
	tx := db.Session(&amp;gorm.Session{Logger: logger.Discard}).Begin() // 不打印错误日志，拿到锁会占用一个数据库连接&#13;
	exist, err := FindOne(tx.Clauses(clause.Locking{Strength: 'UPDATE', Options: 'NOWAIT'}).Where('name = ?', ServiceDeploymentNameGlobalJobLock), &amp;deployment)&#13;
	if err != nil {&#13;
		if pgErr, ok := err.(*pgconn.PgError); ok &amp;&amp; pgErr.Code == '55P03' {&#13;
			err = nil&#13;
		}&#13;
		_ = tx.Rollback()&#13;
	}&#13;
	return exist, err&#13;
}&#13;
&#13;
func stopTickerUntil(ctx context.Context, duration time.Duration, stopFunc func() bool) error {&#13;
	ticker := time.NewTicker(duration)&#13;
	defer ticker.Stop()&#13;
&#13;
Loop:&#13;
	for {&#13;
		select {&#13;
		case &lt;-ctx.Done():&#13;
			return ctx.Err()&#13;
		case &lt;-ticker.C:&#13;
			if stopFunc() {&#13;
				break Loop&#13;
			}&#13;
		}&#13;
	}&#13;
	return nil&#13;
}&#13;
&#13;
func RunJob(ctx context.Context) error {&#13;
	// run job&#13;
	return nil&#13;
}&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-tong-guo-shu-ju-ku-quan-ju-suo-fang-shi-shi-xian-ren-wu-dan-jie-dian-zhi-xing.html</guid><pubDate>Fri, 27 Sep 2024 07:01:48 +0000</pubDate></item><item><title>Clickhouse 留存分析中如何计算分析主体的留存情况</title><link>https://night1008.github.io/post/Clickhouse%20-liu-cun-fen-xi-zhong-ru-he-ji-suan-fen-xi-zhu-ti-de-liu-cun-qing-kuang.html</link><description>## 背景&#13;
&#13;
先明确留存分析相关的概念，&#13;
**留存分析**：衡量不同批次新增用户的数据表现，最常见的就是留存率&#13;
**分析主体**：触发事件的主体，比如用户&#13;
**初始事件**：代表新增的事件，比如用户注册&#13;
**回访事件**：代表活跃的事件，比如用户登录&#13;
**回访用户同时参与事件**：代表活跃的事件，比如用户充值&#13;
&#13;
## 需求&#13;
&#13;
产品给出的关于留存定义为：**某天完成了初始事件的分析主体，在初始事件日期后的第 1 日至第 N 日有完成“回访事件”，即为第 N 日的“留存用户”**。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20-liu-cun-fen-xi-zhong-ru-he-ji-suan-fen-xi-zhu-ti-de-liu-cun-qing-kuang.html</guid><pubDate>Thu, 12 Sep 2024 09:49:38 +0000</pubDate></item><item><title>Clickhouse 留存分析中如何计算分析主体的流失数</title><link>https://night1008.github.io/post/Clickhouse%20-liu-cun-fen-xi-zhong-ru-he-ji-suan-fen-xi-zhu-ti-de-liu-shi-shu.html</link><description>### 背景&#13;
&#13;
先明确留存分析相关的概念&#13;
**留存分析**：衡量不同批次新增用户的数据表现，最常见的就是留存率&#13;
**分析主体**：触发事件的主体，比如用户&#13;
**初始事件**：代表新增的事件，比如用户注册&#13;
**回访事件**：代表活跃的事件，比如用户登录&#13;
&#13;
---&#13;
&#13;
### 需求&#13;
&#13;
产品给出的流失定义为：某天完成了初始事件的分析主体，在初始事件日期后的第 1 日至第 N 日都没有完成“回访事件”，即为第 N 日的“流失用户”。</description><guid isPermaLink="true">https://night1008.github.io/post/Clickhouse%20-liu-cun-fen-xi-zhong-ru-he-ji-suan-fen-xi-zhu-ti-de-liu-shi-shu.html</guid><pubDate>Mon, 19 Aug 2024 08:25:07 +0000</pubDate></item><item><title>看过的电影合集</title><link>https://night1008.github.io/post/kan-guo-de-dian-ying-he-ji.html</link><description>电影链接到 [豆瓣电影](https://movie.douban.com)&#13;
---&#13;
&#13;
- [ ] [九龙城寨之围城](https://movie.douban.com/subject/24284175) (一般)&#13;
- [ ] [年会不能停](https://movie.douban.com/subject/35725869) (还可以)&#13;
- [ ] [三大队](https://movie.douban.com/subject/35208463) (还可以)&#13;
- [ ] [孤注一掷](https://movie.douban.com/subject/35267224) (还可以)&#13;
- [ ] [瀑布](https://movie.douban.com/subject/35242938) (还可以)&#13;
- [ ] [周处除三害](https://movie.douban.com/subject/36151692) (还可以)&#13;
- [ ] [老狐狸](https://movie.douban.com/subject/35611467) (不错)&#13;
- [ ] [破墓](https://movie.douban.com/subject/35490167) (还可以)&#13;
- [ ] [首](https://movie.douban.com/subject/35359717) (还可以)&#13;
- [ ] [沙丘1](https://movie.douban.com/subject/3001114) (还可以)&#13;
- [ ] [沙丘2](https://movie.douban.com/subject/35575567) (还可以)&#13;
- [ ] [月满轩尼诗](https://movie.douban.com/subject/3777800) (还可以)&#13;
- [ ] [因果报应 Maharaja](https://movie.douban.com/subject/36934908/) (还不错)&#13;
- [ ] [心里的声音](https://movie.douban.com/subject/26435723/) (还可以)&#13;
- [ ] [椒麻堂会](https://movie.douban.com/subject/27305997/) (有点意思)。</description><guid isPermaLink="true">https://night1008.github.io/post/kan-guo-de-dian-ying-he-ji.html</guid><pubDate>Sat, 06 Jul 2024 14:59:53 +0000</pubDate></item><item><title>Go recover from panic</title><link>https://night1008.github.io/post/Go%20recover%20from%20panic.html</link><description>```go&#13;
package main&#13;
&#13;
import (&#13;
	'fmt'&#13;
	'runtime/debug'&#13;
	'time'&#13;
&#13;
	'github.com/rs/zerolog/log'&#13;
)&#13;
&#13;
func Recover() {&#13;
	if r := recover(); r != nil {&#13;
		debugStack := string(debug.Stack())&#13;
		fmt.Println(debugStack)&#13;
		log.Error().Err(fmt.Errorf('%s', debugStack)).Msg('recover from panic')&#13;
	}&#13;
}&#13;
&#13;
func main() {&#13;
	go func() {&#13;
		defer Recover()&#13;
		var ss []string&#13;
		fmt.Println(ss[1])&#13;
	}()&#13;
&#13;
	time.Sleep(100 * time.Millisecond)&#13;
&#13;
	fmt.Println('===&gt; enter end')&#13;
}&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20recover%20from%20panic.html</guid><pubDate>Fri, 05 Jul 2024 09:30:36 +0000</pubDate></item><item><title>Go 如何实现事件分析分组排序</title><link>https://night1008.github.io/post/Go%20-ru-he-shi-xian-shi-jian-fen-xi-fen-zu-pai-xu.html</link><description>事件分析过程中，会对分组进行排序，有如下的排序规则，&#13;
&#13;
1. 按第一个指标值的正序排列&#13;
2. 按第一个指标值的倒序排列&#13;
3. 按分组值的正序排列&#13;
4. 按分组值的倒序排列&#13;
&#13;
分组是 `[][]string` 类型，值是 `float64` 类型，&#13;
&#13;
下面记录下主要的排序代码&#13;
&#13;
```go&#13;
const (&#13;
	PropertyTypeInteger              = 'integer'                // 整数类型&#13;
	PropertyTypeFloat                = 'float'                  // 浮点类型，对应 float64 或 double&#13;
	PropertyTypeNumber               = 'number'                 // 浮点类型，对应 float64 或 double&#13;
)&#13;
&#13;
type EventModelQueryGroupBy struct {&#13;
	Name              string    `json:'name' example:'_time'`&#13;
	Type              string    `json:'type' example:'timestamp'`&#13;
	Title             string    `json:'title' example:'事件发生时间'`&#13;
	TableType         string    `json:'table_type' example:'event'`&#13;
	MetaType          string    `json:'meta_type' example:'custom'`&#13;
}&#13;
&#13;
// 根据分组值排序&#13;
func sortUnionGroupsByValue(unionGroups [][]string, unionGroupsValueMap map[string]float64, unionGroupsJoinSymbol string, sortByAsc bool) [][]string {&#13;
	newUnionGroups := make([][]string, len(unionGroups))&#13;
	copy(newUnionGroups, unionGroups)&#13;
	sort.Slice(newUnionGroups, func(i, j int) bool {&#13;
		sortValue := false&#13;
		if sortByAsc {&#13;
			sortValue = unionGroupsValueMap[strings.Join(newUnionGroups[i], unionGroupsJoinSymbol)] &lt; unionGroupsValueMap[strings.Join(newUnionGroups[j], unionGroupsJoinSymbol)]&#13;
		} else {&#13;
			sortValue = unionGroupsValueMap[strings.Join(newUnionGroups[i], unionGroupsJoinSymbol)] &gt; unionGroupsValueMap[strings.Join(newUnionGroups[j], unionGroupsJoinSymbol)]&#13;
		}&#13;
		return sortValue&#13;
	})&#13;
	return newUnionGroups&#13;
}&#13;
&#13;
// 根据分组名称排序&#13;
func sortUnionGroupsByGroup(unionGroups [][]string, unionGroupBy []*EventModelQueryGroupBy, sortByAsc bool) [][]string {&#13;
	newUnionGroups := make([][]string, len(unionGroups))&#13;
	copy(newUnionGroups, unionGroups)&#13;
	sort.Slice(newUnionGroups, func(i, j int) bool {&#13;
		sortValue := false&#13;
		for index := range unionGroupBy {&#13;
			if newUnionGroups[i][index] != newUnionGroups[j][index] {&#13;
				switch unionGroupBy[index].Type {&#13;
				case PropertyTypeInteger, PropertyTypeNumber:&#13;
					if sortByAsc {&#13;
						sortValue = sortValue || parseNumberRangeSortValue(newUnionGroups[i][index]) &lt; parseNumberRangeSortValue(newUnionGroups[j][index])&#13;
					} else {&#13;
						sortValue = sortValue || parseNumberRangeSortValue(newUnionGroups[i][index]) &gt; parseNumberRangeSortValue(newUnionGroups[j][index])&#13;
					}&#13;
				default:&#13;
					if sortByAsc {&#13;
						sortValue = sortValue || newUnionGroups[i][index] &lt; newUnionGroups[j][index]&#13;
					} else {&#13;
						sortValue = sortValue || newUnionGroups[i][index] &gt; newUnionGroups[j][index]&#13;
					}&#13;
				}&#13;
				break&#13;
			}&#13;
		}&#13;
		return sortValue&#13;
	})&#13;
	return newUnionGroups&#13;
}&#13;
&#13;
// 对数值类型分组值拆分得到排序值 [-∞, 100), [-1, 2), 100, (null)&#13;
func parseNumberRangeSortValue(valueStr string) float64 {&#13;
	firstPartValue := strings.SplitN(valueStr, ',', 2)[0]&#13;
	firstPartValue = strings.TrimLeft(firstPartValue, '[')&#13;
	switch firstPartValue {&#13;
	case '-∞':&#13;
		return math.Inf(-1)&#13;
	case '(null)':&#13;
		return math.NaN()&#13;
	default:&#13;
		value, err := strconv.ParseFloat(firstPartValue, 64)&#13;
		if err != nil {&#13;
			return math.Inf(-1)&#13;
		}&#13;
		return value&#13;
	}&#13;
}&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-ru-he-shi-xian-shi-jian-fen-xi-fen-zu-pai-xu.html</guid><pubDate>Thu, 04 Jul 2024 07:01:03 +0000</pubDate></item><item><title>Go mod 如何替换 fork 的包和版本</title><link>https://night1008.github.io/post/Go%20mod%20-ru-he-ti-huan-%20fork%20-de-bao-he-ban-ben.html</link><description>以  `github.com/prashanthpai/sqlcache` 为例，想替换成 fork 的包 `github.com/night1008/sqlcache`，&#13;
假设当前该包的版本为 `v0.0.0`&#13;
&#13;
#### 第一步&#13;
```&#13;
go mod edit -replace github.com/prashanthpai/sqlcache@v0.0.0=github.com/night1008/sqlcache@master&#13;
```&#13;
&#13;
---&#13;
&#13;
#### 第二步&#13;
```&#13;
go get -u github.com/night1008/sqlcache&#13;
```&#13;
&#13;
会有以下提示&#13;
```&#13;
go: downloading github.com/night1008/sqlcache v0.0.0-20240623031410-4d47c940a2d7&#13;
go: github.com/night1008/sqlcache@v0.0.0-20240623031410-4d47c940a2d7: parsing go.mod:&#13;
	module declares its path as: github.com/prashanthpai/sqlcache&#13;
	        but was required as: github.com/night1008/sqlcache&#13;
```&#13;
&#13;
---&#13;
&#13;
#### 第三步&#13;
&#13;
手动把 v0.0.0-20240623031410-4d47c940a2d7 替换到 go.mod `replace github.com/prashanthpai/sqlcache v0.0.0 =&gt; github.com/night1008/sqlcache master` 这一行的 master&#13;
&#13;
---&#13;
&#13;
#### 第四步&#13;
```&#13;
go mod tidy&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20mod%20-ru-he-ti-huan-%20fork%20-de-bao-he-ban-ben.html</guid><pubDate>Wed, 26 Jun 2024 06:52:27 +0000</pubDate></item><item><title>如何使用 GORM 创建或者更新数据库记录</title><link>https://night1008.github.io/post/ru-he-shi-yong-%20GORM%20-chuang-jian-huo-zhe-geng-xin-shu-ju-ku-ji-lu.html</link><description>写业务过程中，经过会遇到当数据不存在则创建记录，已存在则更新记录的情况，&#13;
&#13;
一开始使用一下代码中的第一种方式，发现没生效，后面改成第二种才生效，在此记录一下。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-shi-yong-%20GORM%20-chuang-jian-huo-zhe-geng-xin-shu-ju-ku-ji-lu.html</guid><pubDate>Sat, 22 Jun 2024 04:12:24 +0000</pubDate></item><item><title>Go 如何实现 Clickhouse 查询缓存</title><link>https://night1008.github.io/post/Go%20-ru-he-shi-xian-%20Clickhouse%20-cha-xun-huan-cun.html</link><description>**整体思路：先判断是否命中缓存，没有的话再进入查询队列**&#13;
&#13;
依赖的包&#13;
```&#13;
https://github.com/ClickHouse/ClickHouse&#13;
&#13;
https://github.com/prashanthpai/sqlcache =&gt; https://github.com/night1008/sqlcache&#13;
&#13;
https://github.com/DATA-DOG/go-sqlmock&#13;
&#13;
https://github.com/blockloop/scan&#13;
```&#13;
&#13;
现在的问题是 clickhouse 的查询结果可能返回复杂类型，比如 Map(String, UInt8)，&#13;
如果命中缓存，缓存的结果为 `driver.Rows`，需要转换成 `*sql.Rows` 方便后续使用，&#13;
因此想到通过 `sqlmock` 的方式，但是默认的 `value converter` 是 `driver.DefaultParameterConverter`，只能转换基础类型，&#13;
复杂类型也没有定义专门用于解析的结构体，会报诸如以下的错误，&#13;
&#13;
&gt; panic: row #1, column #2 ('mapper') type map[string]uint8: unsupported type map[string]uint8, a map&#13;
&#13;
好在 `go-sqlmock` 可以指定 `ValueConverterOption`，这样就可以把 `driver.Rows` 转换成 `*sql.Rows` 了。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-ru-he-shi-xian-%20Clickhouse%20-cha-xun-huan-cun.html</guid><pubDate>Sun, 09 Jun 2024 06:43:22 +0000</pubDate></item><item><title>Go 有趣的代码片段</title><link>https://night1008.github.io/post/Go%20-you-qu-de-dai-ma-pian-duan.html</link><description>### 可以对 error 进行 switch 判断&#13;
&#13;
来源：https://github.com/prashanthpai/sqlcache/blob/4bf943bfd00f02394a480c5437e86af4b5be074c/cache_redis.go#L24&#13;
&#13;
```go&#13;
func (r *Redis) Get(ctx context.Context, key string) (*cache.Item, bool, error) {&#13;
	b, err := r.c.Get(ctx, r.keyPrefix+key).Bytes()&#13;
	switch err {&#13;
	case nil:&#13;
		var item cache.Item&#13;
		if err := msgpack.Unmarshal(b, &amp;item); err != nil {&#13;
			return nil, true, err&#13;
		}&#13;
		return &amp;item, true, nil&#13;
	case redis.Nil:&#13;
		return nil, false, nil&#13;
	default:&#13;
		return nil, false, err&#13;
	}&#13;
}&#13;
```&#13;
&#13;
---&#13;
&#13;
### 匿名结构体&#13;
&#13;
来源：https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/concurrency#channels&#13;
&#13;
```go&#13;
type result struct {&#13;
	string&#13;
	bool&#13;
}&#13;
&#13;
var r result&#13;
fmt.Println(r.string, r.bool)&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-you-qu-de-dai-ma-pian-duan.html</guid><pubDate>Sat, 01 Jun 2024 13:01:05 +0000</pubDate></item><item><title>分析平台中的业务关系图</title><link>https://night1008.github.io/post/fen-xi-ping-tai-zhong-de-ye-wu-guan-xi-tu.html</link><description>### 用户和应用角色之间的关系&#13;
![user_role_permission](https://github.com/night1008/night1008.github.io/assets/3940006/214e5136-2ac8-453f-8ddb-e4cd865e4027)&#13;
&#13;
---&#13;
&#13;
### 表和属性之间的关系&#13;
![event_property](https://github.com/night1008/night1008.github.io/assets/3940006/33933ff6-4c26-434b-a190-3ed98f2b5bc9)&#13;
&#13;
&#13;
---&#13;
&#13;
### 看板空间和看板之间的关系&#13;
![dashboard_space](https://github.com/night1008/night1008.github.io/assets/3940006/40200478-f311-40a1-ba05-1e3e0a80a394)&#13;
。</description><guid isPermaLink="true">https://night1008.github.io/post/fen-xi-ping-tai-zhong-de-ye-wu-guan-xi-tu.html</guid><pubDate>Thu, 25 Apr 2024 09:17:32 +0000</pubDate></item><item><title>如何在 iOS 上安装 PokeMMO</title><link>https://night1008.github.io/post/ru-he-zai-%20iOS%20-shang-an-zhuang-%20PokeMMO.html</link><description>准备条件：&#13;
1.  [PokeMMO Account](https://pokemmo.com/en/)&#13;
2. [AltStore](https://iosdroids.com/altstore/)&#13;
3. [PokeMMO ROMS](https://iosdroids.com/pokemmo-ios/)&#13;
&#13;
找了好久总算在 [How to Download &amp; Install PokeMMO on iOS?](https://iosdroids.com/pokemmo-ios/) 找到可下载的 PokeMMO ROMS.&#13;
。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-zai-%20iOS%20-shang-an-zhuang-%20PokeMMO.html</guid><pubDate>Sun, 14 Apr 2024 14:55:47 +0000</pubDate></item><item><title>clickhouse-go 某些查询不会返回查询错误</title><link>https://night1008.github.io/post/clickhouse-go%20-mou-xie-cha-xun-bu-hui-fan-hui-cha-xun-cuo-wu.html</link><description>使用 [clickhouse-go](https://github.com/ClickHouse/clickhouse-go) 作为客户端进行 clickhouse 查询时，发现某些查询不会返回查询错误，&#13;
1. 查询时间超过最大查询时间参数 (max_execution_time)&#13;
2. 非法查询，比如 sleep(300)&#13;
&#13;
下面给示例，&#13;
&#13;
```go&#13;
package main&#13;
&#13;
import (&#13;
	'context'&#13;
	'fmt'&#13;
	'log'&#13;
&#13;
	'github.com/ClickHouse/clickhouse-go/v2'&#13;
)&#13;
&#13;
func main() {&#13;
	db := clickhouse.OpenDB(&amp;clickhouse.Options{&#13;
		Addr: []string{'127.0.0.1:9000'},&#13;
		Auth: clickhouse.Auth{&#13;
			Database: 'default',&#13;
			Username: 'default',&#13;
			Password: '',&#13;
		},&#13;
		Settings: clickhouse.Settings{&#13;
			'join_use_nulls': 1,&#13;
		},&#13;
	})&#13;
&#13;
	ctx := context.Background()&#13;
	conn, err := db.Conn(ctx)&#13;
	if err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
	defer conn.Close()&#13;
&#13;
	sql := 'select sleep(300)'&#13;
	rows, err := conn.QueryContext(ctx, sql)&#13;
	if err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
	defer rows.Close()&#13;
&#13;
	fmt.Println(rows.Columns())&#13;
}&#13;
```&#13;
&#13;
期望结果是，&#13;
```&#13;
code: 160, message: The maximum sleep time is 3000000 microseconds. Requested: 300: while executing 'FUNCTION sleep(300 :: 0) -&gt; sleep(300) UInt8 : 1'&#13;
```&#13;
&#13;
执行结果是，&#13;
```&#13;
[sleep(300)] &lt;nil&gt;&#13;
```&#13;
&#13;
---&#13;
&#13;
问了官方，说是，&#13;
Since the error is not thrown in ClickHouse at the time of query retrieval but later with the data packet, the client has to process data received from the server explicitly using rows.Next().&#13;
&#13;
See code snippet:&#13;
```go&#13;
package issues&#13;
&#13;
import (&#13;
	'context'&#13;
	'testing'&#13;
&#13;
	clickhouse_tests 'github.com/ClickHouse/clickhouse-go/v2/tests'&#13;
	'github.com/stretchr/testify/assert'&#13;
	'github.com/stretchr/testify/require'&#13;
)&#13;
&#13;
func Test1268(t *testing.T) {&#13;
	conn, err := clickhouse_tests.GetDatabaseSQLConnection('issues', nil, nil, nil)&#13;
	require.NoError(t, err)&#13;
&#13;
	rows, err := conn.QueryContext(context.Background(), 'select sleep(300)')&#13;
	require.NoError(t, err)&#13;
	defer rows.Close()&#13;
&#13;
	for rows.Next() {&#13;
		if rows.Err() != nil {&#13;
			break&#13;
		}&#13;
	}&#13;
&#13;
	assert.ErrorContains(t, rows.Err(), 'code: 160, message: The maximum sleep time is 3000000 microseconds.')&#13;
}&#13;
```。</description><guid isPermaLink="true">https://night1008.github.io/post/clickhouse-go%20-mou-xie-cha-xun-bu-hui-fan-hui-cha-xun-cuo-wu.html</guid><pubDate>Sun, 14 Apr 2024 04:00:07 +0000</pubDate></item><item><title>Go 语言下如何提交包含反引号的多行字符串表单</title><link>https://night1008.github.io/post/Go%20-yu-yan-xia-ru-he-ti-jiao-bao-han-fan-yin-hao-de-duo-xing-zi-fu-chuan-biao-dan.html</link><description>感觉 Go 语言对于多行字符串的支持不是很友好。</description><guid isPermaLink="true">https://night1008.github.io/post/Go%20-yu-yan-xia-ru-he-ti-jiao-bao-han-fan-yin-hao-de-duo-xing-zi-fu-chuan-biao-dan.html</guid><pubDate>Sun, 14 Apr 2024 03:57:34 +0000</pubDate></item><item><title>如何实现超管登录</title><link>https://night1008.github.io/post/ru-he-shi-xian-chao-guan-deng-lu.html</link><description>对于 ToC 平台，随着接入应用的增加，用户反馈的问题也变多，&#13;
日志没有记录到的话，加上现有的权限体系下查看问题不方便，&#13;
很难复现问题，需要一个个加到对应的应用中。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-shi-xian-chao-guan-deng-lu.html</guid><pubDate>Thu, 15 Feb 2024 04:40:48 +0000</pubDate></item><item><title>如何进行前后端静态资源分离</title><link>https://night1008.github.io/post/ru-he-jin-xing-qian-hou-duan-jing-tai-zi-yuan-fen-li.html</link><description>我目前开发的平台的前端静态资源是使用 [go embed](https://pkg.go.dev/embed) 机制内嵌到后端服务中，&#13;
当访问量比较大的时候，服务器会有比较大的 IO 消耗，因此进行前端静态资源分离。</description><guid isPermaLink="true">https://night1008.github.io/post/ru-he-jin-xing-qian-hou-duan-jing-tai-zi-yuan-fen-li.html</guid><pubDate>Wed, 14 Feb 2024 04:40:48 +0000</pubDate></item></channel></rss>